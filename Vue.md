
在过去的几年中，我们可以通过JavaScript更强大的实现和页面动态交互效果，我们将原来在服务端的大量代码移动到了浏览器端执行，但这样的行为留给了我们数以千计的JavaScript代码需要和html页面，与css进行关联使用，但是我们却并没有什么规范组织代码的方法，这也是大量的开发者使用framework进行开发的原因。



库：本质上是一些函数的集合 [每次调用函数，实现一个特定的功能，接着把控制权交给使用者,Jquery 就是其中一个典型的代表]

Framework：是一套完善的解决方案 [框架会在合适的时机调用你的代码]

[核心点：谁起到主导作用]，框架实现了一个控制反转的效果

Vuex 实现了vue组件之间的状态管理，同样的实现了与 Vue 相同的响应式数据的效果，什么是响应式原理呢，再接下来的过程中我们会逐步的介绍。
Vue 生态系统，包括了 Devtools（浏览器扩展用于调试Vue.js应用程序）、Vue_cli（@vue/cli + @vue/cli-service-global、@vue/cli-service【基于 webpack 构建、可以通过项目内的配置文件进行配置、可以通过插件进行扩展，帮你搭建好基本的开发环境，包含生成基本项目结构、基本代码和开发流程的基本配置和脚本】）、Vueloader、VueRouter、Vue服务端渲染等一系列、elemnetUi（前端开源基于Vue框架，类似社区里还有很多插件和开源项目）




#
#### 组件化开发

> ES6语法：

什么是js 的异步编程模型？
因为 Js 在设计之初就是一门单线程语言，为了实现主线程不阻塞，event loop 这样的解决方案孕育而生，并且浏览器线程之间的联系都是基于事件的，Js 引擎处理到和其他引擎相关的代码时，就会分发给其他线程，并不会阻塞自身执行，其他线程执行完毕后就会在任务队列中添加一个事件的回调。因为单线程的原因，同一时间只能执行一个方法，于是这些方法被排在了一个叫做执行上下文栈的地方，当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码。这就是 js 的异步编程模型。


回调地狱不是最糟糕的，主要是与人线性思考的逻辑相违背，以至于我们需要花很多精力思考真正的执行顺序

难以复用中间环节：由于无法预期完成的顺序，我们很有可能需要借助外层的变量控制状态与计算，回调函数中引用了外层的变量，提取出来后还需要对外层的代码进行修改，很难抽象出封装函数。promise 可以解决上述的大部分问题，promise 是一个对象，保存着未来才会结束事件的结果，通过模拟事件队列的方式实现。

async 与 await 其实就是 进一步优化了 promise 语法，await 可以实现一个等待的功能，async/await被成为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行

#### 痛点问题

在PMIS系统如供应商选择这一个功能这样类似风格的界面，在在需求、组织和评审环节三个环节中都出现过，那么问题是，同样的一个页面我们需要 copy 三份到不同的目录位置，不仅在平时的代码维护与优化的过程中，我们可能因为不同环节需要不同的样式与业务逻辑还需要将耦合页面中的id重新命名以增加辨识度，即便是这样我们有时还是因为相同的界面与近似的id而感到头痛，现在 Vue 通过组件化，可以把页面拆分为多个组件，每个组件依赖的html、css、JavaScript放在一起进行开发与维护，我们只需要在使用组件的页面（视为父组件）中引入我们的子组件即可，不用再向以前一样，jsp界面中累积大量重复且可辨性很差的代码。

内联样式的使用，css不建议使用内联样式的，因为其并不符合表现和内容相分离的设计原则，内联样式不仅丧失了样式表的许多优势，反而需要JavaScript通过CSS API 接口动态操作样式，与此同时我们又增加了js代码与css代码的耦合度。久而久之代码自然特别厚重，逐渐变得难以维护和更新。而 vue 文件以中包含了页面对应的html、css与Js代码，当我们引入这个页面后相当于引入了对应的结构、样式和Js代码，也就是前端组件化中最想要看到的结果，通过Vue通过在组件的css代码块书写遍基础样式，轻松的实现了解耦，并且你可以在父组件（引用组件）的模块中对组件应用上自己的私有样式，也就是使组件属性也变为可配置


实现页面的加载是通过请求服务器返回一个嵌入了当前模块所有文件的资源路径的jsp界面，包括很多暂时还不需要展示的界面和Js代码（性能很差），而 Vue 中的所有静态资源都是以模块的形式存在的，  vue-cli 可以帮你搭建好基本的开发环境，其中包含生成基本项目结构、基本代码和开发流程的基本配置和脚本，只需要在 webpack 配置入口文件，webpack 会自动处理模块之间有依赖关系（并快速的将其打包成为一个或多个bundle，做了很多性能优化方面的处理），对于这样一个有依赖关系的模块群，通过webpack打包之后，成为浏览器可以直接运行的JavaScript、css和真实图片文件，并且让我们文件很大，首页加载时间很长的时候，可以做到按需加载，在页面加载时大的文件模块在一开始并不会被和其他模块一起打包，而是用户实现与浏览器发生交互的时候，再去请求被独立打包的Js文件。

模态框 vs Vue router

```
# 后端路由
浏览器发出请求，服务器监听到 80 端口请求，并解析url路径，根据服务器的路由配置，返回相应信息，
浏览器根据数据包的 Content-Type 来决定如何解析数据

随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。
单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。
hash模式：#后面值发生变化，并不会导致浏览器向服务器发出请求。
HTML5 标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。

根据不同路径映射到不同视图
```

ajax vs 组件通信

```bash
# 组件通信原理

简单的实现发布订阅模式的思路：每个“主题事件”对应的就是一个函数数组，每次 on 某个事件的时候就是把函数压到对应的函
数数组当中；每次 emit 的时候相当于把事件名对应的函数数组遍历一遍进行调用；每次 off 的时候把目标函数从数组当中剔除。
```

#
> 首先介绍几点JavaScript中比较核心的概念：

#### 1. 什么是对象？

```bash
对象可以看做是属性的无序集合，每个属性都是一个名/值（字符串/值可以是任意数据类型）对,我们可以把对象看成是从字符串到
值的映射，不仅如此，除了可以保持自身属性，对象还可以从一个称为原型的对象中继承属性。JavaScript 对象作为引用类型存
放在堆中
```

#### 2. 文档对象模型（DOM）

> 首先我们来了解一下什么是 DOM（document Object model） 规范

```bash
在 DOM 规范出现之前，因为没有规范和标准，IE 4.0 和 Netscape navigator4.0（发布脚本语言 JavaScript 的公司）
两种浏览器的实现方式完全不同，程序员们不得不写很多探查代码以检测 JavaScript 是运行在什么环境下的，JavaScript 在
人们心目中留下了很差的印象。在各大浏览器厂商大战的同时，W3C 结合大家的优点推出了 DOM1 级规范，将 DOM 定义为了与
平台与语言无关的接口，通过这个接口我们就可以动态的修改页面了。
```

#
#### Virtual DOM

> why virtual dom

```bash
前边我们已经提到了对象与 DOM 的基本概念，DOM 节点就是一个非常复杂的对象。而 Virtual DOM 就是用一个简单的原生
JS 对象去模拟一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多（节省很多内存空间）。在 Vue.js 中，Virtual
DOM 是用 VNode 这么一个 Class 去描述的。


为了更直观的感受~ 继承了6层上层对象实现的属性和方法，这再一次说明 DOM 节点是一个非常复杂的东西，对他每一个属性的访问，
不走运的话就可能会向上溯寻到 N 多个原型链，因此 DOM 操作是个非常耗性能的操作，会触发浏览器的多次回流（多次重新渲染）。


#### 回流的概念

```
想象一下，展示在我们眼前的网页是根据 html 文档的节点关系，DOM 规范将文档映射为了一颗树型结构

我们需要大概了解一下页面从服务器到浏览器展示的过程：浏览器收到并开始解析 html 文档生成 DOM 树，遇到 css 就去下载 css，
遇到 JavaScript 就去下载 javascript，DOM 树结合 css 生成渲染树，浏览器 cpu 绘制多个纹理图层传入GPU 合成展示。这
其中有一个问题就是，JavaScript 是可以动态操作 DOM 树的，也就是我们通常说的操作界面，但是每次修改之后都需要重新绘制，上
传至 GPU 进行重新合成，这是一件很消耗浏览器性能的过程。

```

Vue 的解决措施：
```
为了解决这个问题，Vue 使用了虚拟 DOM 的概念，合并和屏蔽了许多无效的 DOM 操作（不是说不操作 DOM，而是减少操作 DOM 次数），
效果非常惊人。接下来就看看 Vue 是如何实现虚拟 DOM 的。
```

> how it works

```
而 virtual dom 则是通过 JS 层面的计算，返回一个补丁对象，在通过特定的操作解析补丁对象，完成页面的重新渲染。
下来我们来看一下 virtual dom 的核心算法：diff
```

effective

```bash
Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，
依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 
的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。

这才是为什么要有 Virtual DOM：它保证了 
1）不管你的数据变化多少，每次重绘的性能都可以接受；
2) 你依然可以用类似 innerHTML 的思路去写你的应用。
```

#### 1. 同层级元素比较（O(n)）

> 在这里，我们做同级元素比较时，可能会出现四种情况 [这里的元素、节点就是 DOM对象]

```
1. 整个元素都不一样，即元素被replace掉
2. 元素的attrs不一样
3. 元素的text文本不一样
4. 元素顺序被替换，即元素需要reorder

首先我们先从最顶层的元素依次往下进行比较，直到最后一层元素结束，并把每个层级的差异存到 patch 对象中去，即实现 walk 方法

我们用一个数组保存当前新旧节点比较的差异对象
在上层方法中声明一个 pathes 对象通过作用域链的方式保存所有节点差异对象数组

walk 方法里进行了 3 个比较，
第一种是元素被 remove 的情况，这里具体会由 diff 处理
第二种情况是文本不同，我们通过对字符串判等比较
第三种情况是元素属性不同，我们通过 diffAttrs 记录新旧节点
```


#### listdiff 的实现

> 首先我们得明确一下为什么需要 list diff 这种算法的存在，list diff 做的一件事情是怎么样的，然后他又是如何做到这一件事情的

```bash
我们其实可以发现，直接用上面的方法就可以比较出新老对象的差异，但我们这里实质上是做了一次节点的 move，若按照上面的 walk 方法进
行比较，并通过 patches 对象重新解析渲染，那么我们需要操作三次 DOM节点 才能完成视图最后的更新。

# 假设我们原列表有m项，数据更新后列表有n项
# 首先对m个节点进行深度优先遍历比较获得差异对象 patches，o(m)
# 根据差异对象对列表进行重新渲染，o(n)

当然了，如果只有三个节点的话，我们浏览器还吃得消，看不出性能上有啥区别。那么问题来了，要是有 N 多个节点，并且这些节点只是做了一小部分
的 remove、insert、move操作，我们按照一一对应 DOM 操作进行 DOM 重新渲染，那操作确实很昂贵了。

所有才会衍生出list diff这种算法，专门负责收集 remove，insert，move 操作，当然对于这个操作我们需要声明一个 DOM 属性表示该节点的
唯一性，另外在深入之前先上一张图说明一下 list diff 的时间复杂度。
```

```
# newChildren: 

我们看图说话，list diff做的事情就很简单明了啦。

第一步，新节点孩子数组向老节点孩子数组的形式靠近进行操作（移动操作，代码中做法是直接遍历老节点孩子数组操作），
1. 存在 [移动]
2. 不存在 [null]
得到 模拟节点数组 = [key1, 无key, null, key3]
step1. 老节点孩子数组第一个元素key1对应新节点孩子数组中的第二个元素
step2. 老节点孩子数组第二个元素无key对应新节点孩子数组中的第三个元素
step3. 老节点孩子数组第三个元素key2在新节点孩子数组中找不到，直接设为null
step4. 老节点孩子数组第四个元素key3对应新节点孩子数组中的第一个元素
第二步，稍微处理一下得出的模拟节点数组，除去null元素以及新节点孩子数组中的新元素加入，得到模拟节点数组 = 
[key1, 无key, key3, key4]

第三步，将得出的模拟节点数组向新节点孩子数组的形式靠近，并将这里的移动操作全部记录下来（注：元素的move操作
这里会当成remove和insert操作的结合）。所以最后我们得出上图中的一个moves数组，存储了所有节点移动类的操作。

# moves 数组：

在上述操作中，我们遍历了老节点孩子数组与新孩子节点数组，所以时间复杂度自然就是 o(max(m, n))
```

#
### 深入响应式原理

说到这里，又可以结合采购的业务需求进行深入剖析了，我们再业务中经常遇到根据业务需求与数据控制，对不同的用户角色展示
不同的操作界面，或根据用户选择后数据交互的逻辑进行一些页面上的显隐相关的展示变化

```bash
现在我们就来分析一下 Vue 因用户交互而产生的数据发生变化重新对页面进行渲染的原理。
我们可以直观的看到，不使用 vue 的话，我们会通过最简单的方式实现这个需求：监听点
击事件，修改数据，手动操作 DOM 重新渲染，这个过程和使用 Vue 最大的区别就是"手动操作 DOM 重新渲染"。这一步看上去并
不多，但他背后又潜在几个要处理的问题：

1. 我需要修改哪块 DOM
2. 我修改效率和性能是不是最优的
3. 我需要对数据每一次修改都去操作 DOM 吗？
4. 我需要每一个栗子都去修改 DOM 逻辑吗？

如果我们使用了 Vue，那么上面几个问题 Vue 内部就帮你做了，Vue 是如何对我们数据的修改后自动做这些事情呢，接下来进入 
Vue 响应式系统底层的一些细节
```

#### 响应式对象

> 实现核心：利用了 ES5 `Object.defineProperty`，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因

```
Object.defineProperty：在对象上定义一个新属性，或者修改一个对象的现有属性并返回这个，对象该函数会传入一个
descriptor 对象作为参数：代表将被定义或修改的属性描述符，这里最关键的是他提供了 getter/setter 方法，作为存储器
属性不同于普通的数据属性（只有简单的一个值），存取器属性是一个方法，该方法的返回值就是存取表达式的值。

一旦对象拥有了 getter 和 setter，我们可以简单地把这个对象称为响应式对象。我再简单解释一下，在获取对象值的时候，触发
对应的存取器属性方法，那我们在该方法里加入我们想要完成的逻辑操作，是不是就等于我们劫持了对象的属性，对象可以在值r/w时
主动通知我们
```

#
### 依赖收集

1. 什么是依赖收集
2. 依赖收集的流程以及他的目的

> 提到依赖收集就不得不说道设计模式中的观察者模式了

观察者模式：这个模式存在的主要意义就是解耦，当一个主体对象的状态发生改变的时候，所有依赖于它的对象都会得到通知并自动更新，解决了主体对象与订阅者之间功能的耦合，主体对象无需关心如何处理消息

#### 首先让英雄成为可观测对象

```
首先，我们定义一个数据对象，就以王者荣耀里的一个英雄为栗子

1. 我们定义了这个英雄的生命值2000，攻击力为150。但是现在还不知道他是谁，不过这不重要，只需要知道这个英雄将会贯穿我
们整个流程，而我们的目的就是通过这个英雄的属性，知道这个英雄是谁。

2. 现在我们可以通过hero.health和hero.damage直接读写这个英雄对应的属性值。但是，当这个英雄的属性被读取或修改时，我们并
不知情。那么应该如何做才能够让英雄主动告诉我们，他的属性被修改了呢？这时候就需要借助Object.defineProperty的力量了。

3. 我们通过Object.defineProperty方法，对hero属性的r/w进行了劫持，这个属性在被读写的时候都会触发一段浏览器打印信息。
可以看到，英雄已经可以主动告诉我们其属性的读写情况了

```

#### 在属性改变后主动告诉其他信息

```
1. 现在，英雄已经变得可观测，任何的读写操作他都会主动告诉我们，但也仅此而已，我们仍然不知道他是谁。如果我们希望在修改英
雄的生命值和攻击力之后，他能够主动告诉他的其他信息，这应该怎样才能办到呢？假设可以这样：


2. 我们定义了一个watcher作为“监听器”，它监听了hero的role属性。这个type属性的值取决于hero.health，换句话来说，
当hero.health发生变化时，hero.role也应该发生变化，前者是后者的依赖。我们可以把这个hero.role称为“计算属性”。

3. 那么，我们应该怎样才能正确构造这个监听器呢？可以看到，在设想当中，监听器接收三个参数，分别是被监听的对象、被监听的属性
以及回调函数，回调函数返回一个该被监听属性的值。顺着这个思路，我们尝试着编写一段代码：

4. 现在看起来没毛病，一切都运行良好，是不是就这样结束了呢？别忘了，我们现在是通过手动读取hero.role来获取这个英雄的类型，
并不是他主动告诉我们的。如果我们希望让英雄能够在health属性被修改后，第一时间主动发起通知，又该怎么做呢？这就涉及到
核心知识点——依赖收集。
```

#### 实现依赖收集

```
1. 我们知道，当一个可观测对象的属性被读写时，会触发它的getter/setter方法。换个思路，如果我们可以在可观测对象的getter/
setter里面，去执行监听器里面的update()方法，是不是就能够实现让对象主动发出通知的功能呢？

2. 由于监听器内的update()方法需要接收回调函数的值作为参数，而可观测对象内并没有这个回调函数，所以我们需要借助一个第三方来
帮助我们把监听器和可观测对象连接起来。
这个第三方就做一件事情——收集监听器内的回调函数的值以及update()方法。现在我们把这个第三方命名为“依赖收集器”，
一起来看看应该怎么写：


3. 就是这么简单。依赖收集器的target就是用来存放监听器里面的update()方法的。
定义完依赖收集器，我们回到监听器里，看看应该在什么地方把update()方法赋值给Dep.target：

4. 我们在监听器内部定义了一个新的onDepUpdate方法，这个方法很简单，就是把监听器回调函数的值以及
update()给打包到一块，然后赋值给Dep.target。
这一步非常关键，通过这样的操作，依赖收集器就获得了监听器的回调值以及update()方法。
作为全局变量，Dep.target理所当然的能够被可观测对象的getter/setter所使用。


5. 在它的回调函数中，调用了英雄的health属性，也就是触发了对应的getter函数。理清楚这一点很重要，
因为接下来我们需要回到定义可观测对象的defineReactive()方法当中，对它进行改写

我们定义了一个空数组deps，当getter被触发的时候，就会往里面添加一个Dep.target。回到Dep.target
等于监听器的update()方法，这个时候可观测对象已经和监听器捆绑到一块。任何时候当可观测对象的setter
被触发时，就会调用数组中所保存的Dep.target方法，也就是自动触发监听器内部的onDepUpdate()方法。


6. 至于为什么这里的deps是一个数组而不是一个变量，是因为可能同一个属性会被多个计算属性所依赖，也就是存在
多个Dep.target。定义deps为数组，若当前属性的setter被触发，就可以批量调用多个计算属性的 onDepUpdate
方法了。
```

其实Vue实现的响应式原理与依赖收集和上述demo基本是一致的，我们只需要在最开始进行一次 render，那么所有被渲染说依赖的data中的数据就会被getter收集到Dep的subs中去。在对data中的数据进行修改的时候setter只会触发Dep的subs的函数。

具体来说 Vue 在初始化 new 一个对象的时候，会首先传入一个选项参数对象，因为在 Vue 源码中执行 initMixin 函数在 Vue 原型上混入了 _init 函数， 所以Vue 在这个时候会调用 `this._init` 函数进行初始化（主要包括合并 options【我们可以通过$options.el访问选项对象的挂载元素】、生命周期、事件中心、render、state等），在方法的最后对传入的挂载元素进行了挂载的操作。在生命周期钩子 beforeCreate 与 created 间初始化 state 的过程中，对 options 中的数据进行了响应式化的过程（同理也初始化了props、methods）。Vue通过递归遍历的方式劫持了绑定数据对象的所有属性。getter的方法主要用来进行依赖收集，setter方法会在对象被修改的时候触发，这时候setter会通知闭包中的Dep，Dep中有一些订阅了这个对象改变的Watcher观察者对象，Dep会通知Watcher对象更新视图。
这里谈一个小小的细节，就是在JavaScript中数组也是对象类型，但这时候出现了一个问题，如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？。所以需要用继承➕重写数组方法来实现对数组的监听。这里判断数组是否支持 _proro_ 属性，有则直接覆盖数组原型，否则就循坏遍历覆盖数组的方法。

接下来Vue会进行实例挂载，因为 JavaScript 的执行环境不仅仅有浏览器端，所以 Vue 代码的根据不同的运行环境实现了不同对应的平台的代码逻辑，在浏览器环境下，Vue 原型上有一个公共的 mount 方法，因为在 Vue 中所有组件的最终渲染都是通过执行 render 方法完成的，所以在浏览器环境下对该方法进行缓存后重写了mount 方法用来编译最终的 render 方法。接下来 Vue 就会进行模板编译，template 需要被编译为 render 方法，在模板编译的时候会调用一个parse方法解析得到ast语法树（将代码由纯文本解析为AST语法树的数据结构），AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。此时 Vue 会将 AST 树进行优化，生成模板 AST 树，检测不需要进行改变的 DOM 子树，然后把他们变成常数，这样就再也不需要在每次重新渲染时创建新的节点了（也就是在渲染时将静态元素（文本，静态class等）存在一个数组里，然后通过返回数组返回同一个片段，上面说的 diff 算法也会直接跳过静态节点的比较），optimize 主要作用是标记静态节点，然后再调用 generate 将AST语法树转化成render funtion字符串。

通过重写的方法得到编译后的 render 方法后，调用了缓存的 mount 方法，该方法最核心的地方就是实例化了一个渲染 watcher，将 updateComponent 作为回调函数传入，该方法中实现了更新 DOM 的函数 _update（参数是 _render 生成的 VNode）。update 方法的核心函数是 patch 方法，实现了VNode节点到真实 DOM 的转换，并删除原挂载 DOM 节点。其实Watcher并不是实时更新视图的，Vue.js默认会将Watcher对象存在一个队列中，在下一个tick时更新异步更新视图，完成了性能优化。
